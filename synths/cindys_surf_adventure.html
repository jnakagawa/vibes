<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cindy's Surf Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #B0E0E6 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4/3;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border: 3px solid #2C3E50;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        
        #startScreen {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        
        #startScreen h1 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        
        #startScreen button {
            padding: 15px 30px;
            font-size: 20px;
            background: #FF6B6B;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        
        #startScreen button:active {
            transform: scale(0.95);
        }
        
        .hidden {
            display: none !important;
        }
        
        #scorePopup {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: scoreFloat 1s ease-out forwards;
        }
        
        @keyframes scoreFloat {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(1.5);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>Time: <span id="timer">60</span>s</div>
            <div>Score: <span id="score">0</span></div>
        </div>
        <div id="startScreen">
            <h1>üèÑ‚Äç‚ôÄÔ∏è Cindy's Surf Adventure üåä</h1>
            <p style="margin-bottom: 20px;">Tap/Click to jump and flip!<br>Hold to keep flipping!<br>Time your landing!</p>
            <button onclick="startGame()">Start Surfing!</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas resolution (increased height for higher jumps)
        canvas.width = 800;
        canvas.height = 600;
        
        // Game state
        let gameState = {
            running: false,
            score: 0,
            timeLeft: 60,
            wipeoutTimer: 0,
            lastTime: 0
        };
        
        // Player state
        const player = {
            x: 200,
            y: 400,
            baseY: 400,
            velocityY: 0,
            rotation: 0,
            rotationSpeed: 0,
            isJumping: false,
            isFlipping: false,
            flipCount: 0,
            spriteIndex: 0,
            animTimer: 0,
            width: 60,
            height: 90,
            isWipedOut: false
        };
        
        // Wave system
        const waves = [];
        let waveOffset = 0;
        let nextWaveDistance = 0;
        
        // Sprite data
        const sprites = {
            loaded: false,
            image: new Image(),
            frames: []
        };
        
        // Wave sprite data - separate images for each size
        const waveSprites = {
            loaded: 0, // Track how many sprites are loaded
            images: {
                small: new Image(),
                medium: new Image(),
                large: new Image()
            }
        };
        
        // Controls
        let isPressed = false;
        let touchStartY = 0;
        
        // Initialize sprites
        function loadSprites() {
            // Load Cindy sprites
            sprites.image.src = '../source/cindysprite.png';
            sprites.image.onload = () => {
                sprites.loaded = true;
                // Define sprite positions (6 frames in the sprite sheet)
                // Image is 1024x1024 with 3 columns and 2 rows
                const spriteWidth = 341; // 1024 / 3
                const spriteHeight = 512; // 1024 / 2
                for (let i = 0; i < 6; i++) {
                    sprites.frames.push({
                        x: (i % 3) * spriteWidth,
                        y: Math.floor(i / 3) * spriteHeight,
                        width: spriteWidth,
                        height: spriteHeight
                    });
                }
            };
            
            // Load wave sprites - individual images
            const waveTypes = ['small', 'medium', 'large'];
            const waveFiles = ['wavesprite_s.png', 'wavesprite_m.png', 'wavesprite_l.png'];
            
            waveTypes.forEach((type, index) => {
                waveSprites.images[type].src = `../source/${waveFiles[index]}`;
                waveSprites.images[type].onload = () => {
                    waveSprites.loaded++;
                };
            });
        }
        
        // Wave generation
        function generateWave() {
            const waveType = Math.floor(Math.random() * 3); // 0=small, 1=medium, 2=large
            
            // Set dimensions based on actual sprite sizes
            const waveConfigs = [
                { width: 100, height: 60 },  // small: 285x171
                { width: 140, height: 90 },  // medium: 403x258
                { width: 200, height: 120 }  // large: 613x371
            ];
            
            const config = waveConfigs[waveType];
            const wave = {
                x: canvas.width + Math.random() * 200,
                type: waveType,
                width: config.width,
                height: config.height,
                speed: 4 - waveType * 0.5 // Larger waves move slower
            };
            
            waves.push(wave);
        }
        
        // Input handlers
        function handleStart(e) {
            e.preventDefault();
            if (gameState.wipeoutTimer > 0) return;
            
            isPressed = true;
            
            if (!player.isJumping) {
                // Jump - velocity based on wave under player
                player.isJumping = true;
                
                // Check what wave we're on
                let jumpPower = -10; // Base jump for flat water
                for (let wave of waves) {
                    if (player.x >= wave.x && player.x <= wave.x + wave.width) {
                        // On a wave - scale jump based on wave type
                        const wavePowers = [-12, -14, -16]; // small, medium, large
                        jumpPower = wavePowers[wave.type];
                        break;
                    }
                }
                
                player.velocityY = jumpPower;
                player.spriteIndex = 3; // Jump sprite
            } else if (!player.isFlipping) {
                // Start flipping
                player.isFlipping = true;
                player.rotationSpeed = 12; // Increased from 8 for faster rotations
            }
        }
        
        function handleEnd(e) {
            e.preventDefault();
            isPressed = false;
            
            if (player.isFlipping) {
                player.isFlipping = false;
                player.rotationSpeed = 0;
            }
        }
        
        // Game mechanics
        function updatePlayer(deltaTime, timeScale = 1) {
            if (player.isWipedOut) {
                gameState.wipeoutTimer -= deltaTime;
                if (gameState.wipeoutTimer <= 0) {
                    resetPlayer();
                }
                return;
            }
            
            // Apply gravity (reduced for more air time)
            if (player.isJumping) {
                player.velocityY += 0.4 * timeScale; // Frame-rate independent gravity
                player.y += player.velocityY * timeScale;
                
                // Rotation for flips
                if (player.isFlipping && isPressed) {
                    player.rotation += player.rotationSpeed * timeScale;
                    
                    // Count complete flips
                    if (Math.abs(player.rotation) >= 360) {
                        player.flipCount++;
                        player.rotation = player.rotation % 360;
                    }
                }
                
                // Check landing
                const waveY = getWaveHeightAt(player.x);
                if (player.y >= waveY - 10) {
                    land(waveY);
                }
            } else {
                // Follow wave when not jumping
                const waveY = getWaveHeightAt(player.x);
                player.y = waveY - 10;
                player.baseY = player.y;
                
                // Animate surfing sprites
                player.animTimer += deltaTime;
                if (player.animTimer > 150) { // Slightly slower animation for better visibility
                    player.animTimer = 0;
                    player.spriteIndex = (player.spriteIndex + 1) % 3;
                }
            }
        }
        
        function getWaveHeightAt(x) {
            let baseHeight = canvas.height - 200;
            
            for (let wave of waves) {
                if (x >= wave.x && x <= wave.x + wave.width) {
                    const relativeX = x - wave.x;
                    const angle = (relativeX / wave.width) * Math.PI;
                    // Peak is at the center of the wave
                    return baseHeight - Math.sin(angle) * wave.height * 0.7;
                }
            }
            
            return baseHeight;
        }
        
        function land(waveY) {
            player.isJumping = false;
            player.velocityY = 0;
            player.y = waveY - 10;
            
            // Calculate landing score
            let score = 0;
            let message = "";
            
            const rotationMod = Math.abs(player.rotation % 360);
            const isCleanLanding = rotationMod < 30 || rotationMod > 330;
            
            // Only score if there were flips
            if (player.flipCount > 0) {
                if (isCleanLanding) {
                    score = 100 * player.flipCount;
                    if (player.flipCount === 1) {
                        message = `FLIP! +${score}`;
                    } else {
                        message = `${player.flipCount}x FLIP! +${score}`;
                    }
                } else if (rotationMod < 90 || rotationMod > 270) {
                    score = 70 * player.flipCount;
                    message = `Sketchy ${player.flipCount}x! +${score}`;
                } else {
                    // Wipeout!
                    player.isWipedOut = true;
                    gameState.wipeoutTimer = 5000;
                    message = "WIPEOUT!";
                    player.spriteIndex = 5; // Wipeout sprite
                }
            } else if (!isCleanLanding) {
                // No flips and bad landing = wipeout
                player.isWipedOut = true;
                gameState.wipeoutTimer = 5000;
                message = "WIPEOUT!";
                player.spriteIndex = 5;
            }
            
            if (score > 0) {
                gameState.score += score;
                updateScore();
            }
            
            // Only show popup if there's a message (flips or wipeout)
            if (message) {
                showScorePopup(player.x, player.y - 50, message);
            }
            
            // Reset flip state
            player.rotation = 0;
            player.flipCount = 0;
            player.isFlipping = false;
            player.rotationSpeed = 0;
            player.spriteIndex = 0;
        }
        
        function resetPlayer() {
            player.isWipedOut = false;
            player.isJumping = false;
            player.velocityY = 0;
            player.rotation = 0;
            player.flipCount = 0;
            player.isFlipping = false;
            player.spriteIndex = 0;
            const waveY = getWaveHeightAt(player.x);
            player.y = waveY - 10;
        }
        
        function showScorePopup(x, y, text) {
            const popup = document.createElement('div');
            popup.id = 'scorePopup';
            popup.textContent = text;
            popup.style.left = `${(x / canvas.width) * 100}%`;
            popup.style.top = `${(y / canvas.height) * 100}%`;
            document.getElementById('gameContainer').appendChild(popup);
            
            setTimeout(() => popup.remove(), 1000);
        }
        
        function updateScore() {
            document.getElementById('score').textContent = gameState.score;
        }
        
        // Rendering
        function render() {
            // Clear canvas
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ocean gradient
            const gradient = ctx.createLinearGradient(0, canvas.height - 250, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(70, 130, 180, 0.6)');
            gradient.addColorStop(0.5, 'rgba(100, 149, 237, 0.8)');
            gradient.addColorStop(1, 'rgba(65, 105, 225, 1)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, canvas.height - 250, canvas.width, 250);
            
            // Draw waves using sprites
            if (waveSprites.loaded === 3) { // All 3 sprites loaded
                for (let wave of waves) {
                    const waveTypeNames = ['small', 'medium', 'large'];
                    const waveImage = waveSprites.images[waveTypeNames[wave.type]];
                    
                    if (waveImage && waveImage.complete) {
                        // Position wave at water level
                        const waterLevel = canvas.height - 200;
                        const waveY = waterLevel - wave.height;
                        
                        // Draw the wave sprite maintaining aspect ratio
                        ctx.drawImage(
                            waveImage,
                            wave.x, waveY, wave.width, wave.height
                        );
                    }
                }
            } else {
                // Fallback to simple wave drawing if sprites haven't loaded
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 3;
                
                for (let wave of waves) {
                    ctx.beginPath();
                    const waveY = canvas.height - 200;
                    const angle = Math.PI;
                    for (let i = 0; i <= wave.width; i += 10) {
                        const x = wave.x + i;
                        const y = waveY - Math.sin((i / wave.width) * Math.PI) * wave.height;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
            }
            
            // Draw player
            if (sprites.loaded && !player.isWipedOut) {
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate((player.rotation * Math.PI) / 180);
                
                const frame = sprites.frames[player.spriteIndex];
                if (frame) {
                    ctx.drawImage(
                        sprites.image,
                        frame.x, frame.y, frame.width, frame.height,
                        -player.width / 2, -player.height / 2, player.width, player.height
                    );
                }
                
                ctx.restore();
            } else if (player.isWipedOut) {
                // Draw wipeout animation
                ctx.save();
                ctx.translate(player.x, player.y + Math.sin(Date.now() * 0.01) * 5);
                ctx.rotate(Math.sin(Date.now() * 0.005) * 0.3);
                
                const frame = sprites.frames[5];
                if (frame) {
                    ctx.globalAlpha = 0.7;
                    ctx.drawImage(
                        sprites.image,
                        frame.x, frame.y, frame.width, frame.height,
                        -player.width / 2, -player.height / 2, player.width, player.height
                    );
                }
                
                ctx.restore();
                
                // Draw wipeout timer
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`Recovery: ${Math.ceil(gameState.wipeoutTimer / 1000)}s`, player.x, player.y - 80);
            }
            
            // Draw flip counter during flips
            if (player.isFlipping && player.flipCount > 0) {
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 32px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(`${player.flipCount}x`, player.x, player.y - 60);
                ctx.fillText(`${player.flipCount}x`, player.x, player.y - 60);
            }
        }
        
        // Game loop
        function gameLoop(currentTime) {
            if (!gameState.running) return;
            
            const deltaTime = currentTime - gameState.lastTime;
            gameState.lastTime = currentTime;
            
            // Target 60 FPS - normalize deltaTime to maintain consistent speed
            const targetDelta = 1000 / 60; // 16.67ms for 60fps
            const timeScale = deltaTime / targetDelta;
            
            // Update waves with frame-rate independent movement
            const waveScrollSpeed = 3 * timeScale;
            waveOffset += waveScrollSpeed;
            for (let i = waves.length - 1; i >= 0; i--) {
                waves[i].x -= waves[i].speed * timeScale;
                if (waves[i].x + waves[i].width < 0) {
                    waves.splice(i, 1);
                }
            }
            
            // Generate new waves
            nextWaveDistance -= waveScrollSpeed;
            if (nextWaveDistance <= 0) {
                generateWave();
                nextWaveDistance = 200 + Math.random() * 300;
            }
            
            // Update game
            updatePlayer(deltaTime, timeScale);
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Timer
        function updateTimer() {
            if (!gameState.running) return;
            
            gameState.timeLeft--;
            document.getElementById('timer').textContent = gameState.timeLeft;
            
            if (gameState.timeLeft <= 0) {
                endGame();
            } else {
                setTimeout(updateTimer, 1000);
            }
        }
        
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            
            // Reset game state
            gameState.running = true;
            gameState.score = 0;
            gameState.timeLeft = 60;
            gameState.wipeoutTimer = 0;
            gameState.lastTime = performance.now();
            
            // Reset player
            resetPlayer();
            
            // Clear waves and generate initial ones
            waves.length = 0;
            for (let i = 0; i < 3; i++) {
                generateWave();
                waves[waves.length - 1].x = 400 + i * 250;
            }
            
            updateScore();
            updateTimer();
            requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            gameState.running = false;
            
            const startScreen = document.getElementById('startScreen');
            startScreen.classList.remove('hidden');
            startScreen.querySelector('h1').textContent = `Game Over! Score: ${gameState.score}`;
            startScreen.querySelector('button').textContent = 'Play Again';
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchend', handleEnd);
        
        // Prevent context menu on long press
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        // Initialize
        loadSprites();
    </script>
</body>
</html>