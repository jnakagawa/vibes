<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glass Particle Conductor - Dance IX</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: white;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #video-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
            background: #000;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 20px;
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 320px;
        }

        h1 {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 5px;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 0.75em;
            opacity: 0.6;
            margin-bottom: 15px;
            font-style: italic;
        }

        .control-group {
            margin: 12px 0;
        }

        .control-group label {
            display: block;
            font-size: 0.8em;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 6px;
            font-size: 0.9em;
        }

        button {
            padding: 12px 24px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
            transition: all 0.2s;
        }

        #startBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #startBtn:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }

        #stopBtn {
            background: rgba(255, 100, 100, 0.3);
            color: white;
        }

        .hand-info {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }

        .hand-panel {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.75em;
        }

        .left-panel {
            background: rgba(255, 107, 107, 0.15);
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .right-panel {
            background: rgba(78, 205, 196, 0.15);
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .hand-panel h3 {
            font-size: 0.9em;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .hand-panel .param {
            opacity: 0.7;
            margin: 2px 0;
        }

        #status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.8em;
            opacity: 0.8;
        }

        .instructions {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 0.75em;
            line-height: 1.5;
        }

        .instructions strong {
            color: #667eea;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .loading {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <canvas id="overlay"></canvas>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <div id="ui">
        <h1>GLASS PARTICLE CONDUCTOR</h1>
        <div class="subtitle">Inspired by Dance IX</div>

        <button id="startBtn">â–¶ Begin Conducting</button>
        <button id="stopBtn">â–  Stop</button>

        <div class="control-group">
            <label>Master Volume</label>
            <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.6">
        </div>

        <div class="control-group">
            <label>Tempo (BPM)</label>
            <input type="range" id="tempo" min="60" max="180" step="1" value="120">
            <span id="tempoValue">120</span>
        </div>

        <div class="control-group">
            <label>Scale / Mode</label>
            <select id="scaleSelect">
                <option value="dorian">Dorian (Glass favorite)</option>
                <option value="aeolian">Aeolian (Natural Minor)</option>
                <option value="mixolydian">Mixolydian</option>
                <option value="pentatonic">Pentatonic</option>
                <option value="chromatic">Chromatic</option>
            </select>
        </div>

        <div class="control-group">
            <label>Particle Intensity</label>
            <input type="range" id="particleIntensity" min="0.2" max="2" step="0.1" value="1">
        </div>

        <div class="hand-info">
            <div class="hand-panel left-panel">
                <h3>ðŸŽµ LEFT - Rhythm</h3>
                <div class="param" id="leftFingers">Fingers: -</div>
                <div class="param" id="leftGesture">Gesture: -</div>
                <div class="param" id="leftDepth">Depth: -</div>
            </div>
            <div class="hand-panel right-panel">
                <h3>ðŸŽº RIGHT - Melody</h3>
                <div class="param" id="rightFingers">Fingers: -</div>
                <div class="param" id="rightGesture">Gesture: -</div>
                <div class="param" id="rightDepth">Depth: -</div>
            </div>
        </div>

        <div id="status" class="loading">Initializing...</div>

        <div class="instructions">
            <strong>Left Hand (Rhythm):</strong> Controls bass & percussion. Open hand = full rhythm, fist = sparse. Height = register.<br><br>
            <strong>Right Hand (Melody):</strong> Controls horns & woodwinds. Finger count = complexity. Hand rotation = timbre. Distance = dynamics.
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            particleCount: 3000,
            rhythmParticles: 1500,
            melodyParticles: 1500,
            smoothingAlpha: 0.15,
            handDetectionInterval: 100,
            audioLatency: 0.05
        };

        // Musical scales (frequencies in Hz)
        const SCALES = {
            dorian: {
                root: 130.81, // C3
                intervals: [0, 2, 3, 5, 7, 9, 10], // Dorian mode
                name: 'Dorian'
            },
            aeolian: {
                root: 130.81,
                intervals: [0, 2, 3, 5, 7, 8, 10],
                name: 'Aeolian'
            },
            mixolydian: {
                root: 130.81,
                intervals: [0, 2, 4, 5, 7, 9, 10],
                name: 'Mixolydian'
            },
            pentatonic: {
                root: 130.81,
                intervals: [0, 2, 4, 7, 9],
                name: 'Pentatonic'
            },
            chromatic: {
                root: 130.81,
                intervals: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
                name: 'Chromatic'
            }
        };

        // ============================================
        // STATE
        // ============================================
        let scene, camera, renderer;
        let rhythmParticles, melodyParticles;
        let audioCtx, masterGain;
        let handpose, webcamRunning = false;
        let isPlaying = false;

        let currentScale = 'dorian';
        let tempo = 120;

        // Hand tracking state
        const hands = {
            left: null,
            right: null
        };

        // Smoothed values for stable control
        class SmoothedValue {
            constructor(initial = 0, alpha = CONFIG.smoothingAlpha) {
                this.value = initial;
                this.target = initial;
                this.alpha = alpha;
            }

            update(newTarget) {
                this.target = newTarget;
                this.value = this.alpha * this.target + (1 - this.alpha) * this.value;
                return this.value;
            }
        }

        // Smoothed hand data
        const smoothedHands = {
            left: {
                x: new SmoothedValue(0.3),
                y: new SmoothedValue(0.5),
                z: new SmoothedValue(0.5),
                rotation: new SmoothedValue(0),
                openness: new SmoothedValue(0),
                fingerCount: new SmoothedValue(0)
            },
            right: {
                x: new SmoothedValue(0.7),
                y: new SmoothedValue(0.5),
                z: new SmoothedValue(0.5),
                rotation: new SmoothedValue(0),
                openness: new SmoothedValue(0),
                fingerCount: new SmoothedValue(5)
            }
        };

        // Audio voices
        const rhythmVoices = [];
        const melodyVoices = [];
        let rhythmSequencer = null;
        let melodyArpeggiator = null;

        // ============================================
        // THREE.JS PARTICLE SYSTEM
        // ============================================
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            scene.fog = new THREE.FogExp2(0x0a0a0f, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // Create rhythm particles (left hand - warm colors)
            rhythmParticles = createParticleSystem(CONFIG.rhythmParticles, {
                baseColor: new THREE.Color(0xff6b6b),
                size: 0.8,
                spread: 30
            });
            rhythmParticles.position.x = -20;
            scene.add(rhythmParticles);

            // Create melody particles (right hand - cool colors)
            melodyParticles = createParticleSystem(CONFIG.melodyParticles, {
                baseColor: new THREE.Color(0x4ecdc4),
                size: 0.8,
                spread: 30
            });
            melodyParticles.position.x = 20;
            scene.add(melodyParticles);

            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Point lights that follow hands
            const pointLight1 = new THREE.PointLight(0xff6b6b, 1, 100);
            pointLight1.position.set(-20, 0, 20);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x4ecdc4, 1, 100);
            pointLight2.position.set(20, 0, 20);
            scene.add(pointLight2);

            window.addEventListener('resize', onWindowResize);
        }

        function createParticleSystem(count, options) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const velocities = new Float32Array(count * 3);
            const phases = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                // Initial positions in a sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.random() * options.spread;

                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);

                // Colors with variation
                const colorVariation = 0.3;
                colors[i * 3] = options.baseColor.r + (Math.random() - 0.5) * colorVariation;
                colors[i * 3 + 1] = options.baseColor.g + (Math.random() - 0.5) * colorVariation;
                colors[i * 3 + 2] = options.baseColor.b + (Math.random() - 0.5) * colorVariation;

                sizes[i] = options.size * (0.5 + Math.random());

                // Store initial velocities
                velocities[i * 3] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;

                phases[i] = Math.random() * Math.PI * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.userData = { velocities, phases, basePositions: positions.slice() };

            const material = new THREE.PointsMaterial({
                size: options.size,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            return new THREE.Points(geometry, material);
        }

        function updateParticles(particles, handData, isRhythm, time) {
            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            const sizes = particles.geometry.attributes.size.array;
            const { velocities, phases } = particles.geometry.userData;

            const intensity = parseFloat(document.getElementById('particleIntensity').value);
            const count = positions.length / 3;

            // Parameters from hand
            const openness = handData.openness.value;
            const fingerCount = handData.fingerCount.value;
            const depth = handData.z.value;
            const rotation = handData.rotation.value;
            const yPos = handData.y.value;

            // Particle behavior based on hand state
            // Tight grouping for quiet notes, spread for loud
            const spreadFactor = 5 + openness * 25 + depth * 15;
            const speedFactor = 0.5 + openness * 2 + fingerCount * 0.3;
            const sizeFactor = 0.3 + openness * 1.5 + depth * 0.5;

            // Color based on pitch/register (y position)
            const hue = isRhythm ?
                0.0 + yPos * 0.1 : // Red to orange for rhythm
                0.45 + yPos * 0.15; // Cyan to blue for melody

            const saturation = 0.6 + openness * 0.4;
            const lightness = 0.4 + depth * 0.3;

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const phase = phases[i] + time * speedFactor * 0.001;

                // Organic movement
                const noiseX = Math.sin(phase + i * 0.01) * spreadFactor * 0.1;
                const noiseY = Math.cos(phase * 1.3 + i * 0.02) * spreadFactor * 0.1;
                const noiseZ = Math.sin(phase * 0.7 + i * 0.015) * spreadFactor * 0.1;

                // Spiral motion influenced by hand rotation
                const angle = rotation * Math.PI + phase * 0.5;
                const spiralX = Math.cos(angle + i * 0.1) * spreadFactor * 0.3;
                const spiralY = Math.sin(angle + i * 0.1) * spreadFactor * 0.3;

                // Target position
                const baseSpread = spreadFactor * (0.5 + Math.random() * 0.5);
                const targetX = spiralX + noiseX + (Math.random() - 0.5) * baseSpread * 0.2;
                const targetY = spiralY + noiseY + (Math.random() - 0.5) * baseSpread * 0.2;
                const targetZ = noiseZ + (Math.random() - 0.5) * baseSpread * 0.2;

                // Smooth movement toward target
                positions[i3] += (targetX - positions[i3]) * 0.02 * intensity;
                positions[i3 + 1] += (targetY - positions[i3 + 1]) * 0.02 * intensity;
                positions[i3 + 2] += (targetZ - positions[i3 + 2]) * 0.02 * intensity;

                // Update colors dynamically
                const particleHue = hue + (i / count) * 0.1;
                const rgb = hslToRgb(particleHue % 1, saturation, lightness);
                colors[i3] = rgb.r + (Math.sin(phase * 2) * 0.1);
                colors[i3 + 1] = rgb.g + (Math.sin(phase * 2.5) * 0.1);
                colors[i3 + 2] = rgb.b + (Math.sin(phase * 3) * 0.1);

                // Update sizes based on sound intensity
                sizes[i] = sizeFactor * (0.5 + Math.sin(phase) * 0.3) * intensity;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;

            // Update particle material size
            particles.material.size = sizeFactor * intensity;
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r, g, b };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            const overlay = document.getElementById('overlay');
            overlay.width = window.innerWidth;
            overlay.height = window.innerHeight;
        }

        // ============================================
        // HAND TRACKING
        // ============================================
        async function initHandTracking() {
            const video = document.getElementById('webcam');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 }
                });
                video.srcObject = stream;
                await video.play();
                webcamRunning = true;

                // Initialize MediaPipe Hands
                handpose = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });

                handpose.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });

                handpose.onResults(onHandResults);

                // Camera utility for processing
                const cam = new Camera(video, {
                    onFrame: async () => {
                        if (webcamRunning) {
                            await handpose.send({ image: video });
                        }
                    },
                    width: 640,
                    height: 480
                });
                cam.start();

                updateStatus('Hand tracking ready! Click "Begin Conducting"');

            } catch (error) {
                console.error('Hand tracking error:', error);
                updateStatus('Camera access denied. Please allow camera access.');
            }
        }

        function onHandResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                hands.left = null;
                hands.right = null;
                return;
            }

            // Process each detected hand
            results.multiHandLandmarks.forEach((landmarks, index) => {
                const handedness = results.multiHandedness[index].label;
                const handData = processHandLandmarks(landmarks);

                // Mirror handedness since video is mirrored
                if (handedness === 'Right') {
                    hands.left = handData;
                    updateSmoothedHand('left', handData);
                } else {
                    hands.right = handData;
                    updateSmoothedHand('right', handData);
                }
            });

            // Clear hands not detected
            if (results.multiHandLandmarks.length === 1) {
                const detected = results.multiHandedness[0].label;
                if (detected === 'Right') {
                    hands.right = null;
                } else {
                    hands.left = null;
                }
            }

            updateHandUI();
        }

        function processHandLandmarks(landmarks) {
            // Calculate center position
            let sumX = 0, sumY = 0;
            landmarks.forEach(lm => {
                sumX += lm.x;
                sumY += lm.y;
            });
            const centerX = sumX / landmarks.length;
            const centerY = sumY / landmarks.length;

            // Calculate hand openness (distance from wrist to middle fingertip)
            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            const openDistance = Math.sqrt(
                Math.pow(middleTip.x - wrist.x, 2) +
                Math.pow(middleTip.y - wrist.y, 2) +
                Math.pow((middleTip.z || 0) - (wrist.z || 0), 2)
            );
            const openness = Math.min(1, Math.max(0, (openDistance - 0.1) / 0.25));

            // Count extended fingers
            const fingerCount = countExtendedFingers(landmarks);

            // Calculate hand rotation (angle from wrist to middle finger base)
            const middleBase = landmarks[9];
            const rotation = Math.atan2(
                middleBase.y - wrist.y,
                middleBase.x - wrist.x
            ) / Math.PI; // Normalize to -1 to 1

            // Depth estimation from z-coordinates (average)
            let avgZ = 0;
            landmarks.forEach(lm => avgZ += (lm.z || 0));
            avgZ /= landmarks.length;
            const depth = Math.min(1, Math.max(0, 0.5 - avgZ * 5));

            return {
                x: 1 - centerX, // Mirror for intuitive control
                y: centerY,
                z: depth,
                openness,
                fingerCount,
                rotation,
                landmarks
            };
        }

        function countExtendedFingers(landmarks) {
            let count = 0;

            // Finger tip and pip (proximal) indices
            const fingers = [
                { tip: 4, pip: 3, isThumb: true },   // Thumb
                { tip: 8, pip: 6, isThumb: false },  // Index
                { tip: 12, pip: 10, isThumb: false }, // Middle
                { tip: 16, pip: 14, isThumb: false }, // Ring
                { tip: 20, pip: 18, isThumb: false }  // Pinky
            ];

            fingers.forEach(finger => {
                const tip = landmarks[finger.tip];
                const pip = landmarks[finger.pip];

                if (finger.isThumb) {
                    // Thumb uses x-distance
                    const wrist = landmarks[0];
                    if (Math.abs(tip.x - wrist.x) > 0.1) count++;
                } else {
                    // Other fingers: tip should be above pip (lower y)
                    if (tip.y < pip.y - 0.02) count++;
                }
            });

            return count;
        }

        function updateSmoothedHand(hand, data) {
            if (!data) return;
            smoothedHands[hand].x.update(data.x);
            smoothedHands[hand].y.update(data.y);
            smoothedHands[hand].z.update(data.z);
            smoothedHands[hand].rotation.update(data.rotation);
            smoothedHands[hand].openness.update(data.openness);
            smoothedHands[hand].fingerCount.update(data.fingerCount);
        }

        function updateHandUI() {
            const left = hands.left;
            const right = hands.right;

            document.getElementById('leftFingers').textContent =
                `Fingers: ${left ? Math.round(smoothedHands.left.fingerCount.value) : '-'}`;
            document.getElementById('leftGesture').textContent =
                `Gesture: ${left ? (smoothedHands.left.openness.value > 0.5 ? 'Open' : 'Closed') : '-'}`;
            document.getElementById('leftDepth').textContent =
                `Depth: ${left ? smoothedHands.left.z.value.toFixed(2) : '-'}`;

            document.getElementById('rightFingers').textContent =
                `Fingers: ${right ? Math.round(smoothedHands.right.fingerCount.value) : '-'}`;
            document.getElementById('rightGesture').textContent =
                `Gesture: ${right ? (smoothedHands.right.openness.value > 0.5 ? 'Open' : 'Closed') : '-'}`;
            document.getElementById('rightDepth').textContent =
                `Depth: ${right ? smoothedHands.right.z.value.toFixed(2) : '-'}`;
        }

        // ============================================
        // AUDIO ENGINE - Philip Glass Style
        // ============================================
        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Master gain
            masterGain = audioCtx.createGain();
            masterGain.gain.value = parseFloat(document.getElementById('masterVolume').value);

            // Master compressor for cohesion
            const compressor = audioCtx.createDynamicsCompressor();
            compressor.threshold.value = -24;
            compressor.knee.value = 30;
            compressor.ratio.value = 4;
            compressor.attack.value = 0.003;
            compressor.release.value = 0.25;

            // Reverb
            const convolver = createReverb();
            const reverbGain = audioCtx.createGain();
            reverbGain.gain.value = 0.3;

            // Routing
            masterGain.connect(compressor);
            compressor.connect(audioCtx.destination);
            masterGain.connect(convolver);
            convolver.connect(reverbGain);
            reverbGain.connect(audioCtx.destination);
        }

        function createReverb() {
            const convolver = audioCtx.createConvolver();
            const length = audioCtx.sampleRate * 2.5;
            const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);

            for (let channel = 0; channel < 2; channel++) {
                const data = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
                }
            }

            convolver.buffer = impulse;
            return convolver;
        }

        function getScaleFrequencies(scaleName, octave = 3) {
            const scale = SCALES[scaleName];
            const frequencies = [];

            for (let oct = octave - 1; oct <= octave + 2; oct++) {
                scale.intervals.forEach(interval => {
                    const freq = scale.root * Math.pow(2, oct - 3) * Math.pow(2, interval / 12);
                    frequencies.push(freq);
                });
            }

            return frequencies.sort((a, b) => a - b);
        }

        // ============================================
        // RHYTHM SECTION (Left Hand)
        // ============================================
        class RhythmSequencer {
            constructor() {
                this.isPlaying = false;
                this.step = 0;
                this.patterns = this.generateGlassPatterns();
                this.currentPattern = 0;
                this.voices = [];
            }

            generateGlassPatterns() {
                // Philip Glass additive rhythmic patterns
                return [
                    [1, 0, 1, 0, 1, 0, 1, 0],           // Basic pulse
                    [1, 1, 0, 1, 0, 1, 1, 0],           // Syncopated
                    [1, 0, 0, 1, 0, 0, 1, 0],           // Sparse
                    [1, 1, 1, 0, 1, 1, 0, 1],           // Dense
                    [1, 0, 1, 1, 0, 1, 0, 1, 1, 0],     // Additive 5+5
                    [1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0], // Complex
                ];
            }

            start() {
                this.isPlaying = true;
                this.scheduleNext();
            }

            stop() {
                this.isPlaying = false;
                this.voices.forEach(v => {
                    try { v.osc.stop(); } catch(e) {}
                });
                this.voices = [];
            }

            scheduleNext() {
                if (!this.isPlaying) return;

                const tempo = parseFloat(document.getElementById('tempo').value);
                const intervalMs = (60 / tempo / 2) * 1000; // Eighth notes

                this.playStep();

                setTimeout(() => this.scheduleNext(), intervalMs);
            }

            playStep() {
                const handData = smoothedHands.left;
                const openness = handData.openness.value;
                const fingerCount = handData.fingerCount.value;
                const yPos = handData.y.value;
                const depth = handData.z.value;

                // Select pattern based on openness
                const patternIndex = Math.floor(openness * (this.patterns.length - 1));
                const pattern = this.patterns[patternIndex];

                if (pattern[this.step % pattern.length]) {
                    this.playRhythmNote(yPos, depth, fingerCount);
                }

                this.step++;
            }

            playRhythmNote(yPos, depth, fingerCount) {
                const scale = getScaleFrequencies(currentScale);

                // Bass note - lower register
                const bassIndex = Math.floor((1 - yPos) * 7);
                const bassFreq = scale[bassIndex] || scale[0];

                // Volume based on depth and openness
                const volume = 0.15 + depth * 0.2;

                // Create bass voice
                this.createBassNote(bassFreq / 2, volume, fingerCount);

                // Add percussion element if fingers extended
                if (fingerCount > 2) {
                    this.createPercussion(volume * 0.5);
                }
            }

            createBassNote(freq, volume, complexity) {
                const now = audioCtx.currentTime;

                // Main oscillator
                const osc = audioCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = freq;

                // Sub oscillator for depth
                const subOsc = audioCtx.createOscillator();
                subOsc.type = 'sine';
                subOsc.frequency.value = freq / 2;

                // Filter
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400 + complexity * 100;
                filter.Q.value = 1;

                // Envelope
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(volume, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

                const subGain = audioCtx.createGain();
                subGain.gain.value = 0.5;

                // Connect
                osc.connect(filter);
                subOsc.connect(subGain);
                subGain.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);

                osc.start(now);
                subOsc.start(now);
                osc.stop(now + 0.35);
                subOsc.stop(now + 0.35);
            }

            createPercussion(volume) {
                const now = audioCtx.currentTime;

                // Noise burst for percussion
                const bufferSize = audioCtx.sampleRate * 0.1;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
                }

                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 2000;

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(volume, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);

                noise.start(now);
            }
        }

        // ============================================
        // MELODY SECTION (Right Hand) - Horns/Woodwinds
        // ============================================
        class MelodyArpeggiator {
            constructor() {
                this.isPlaying = false;
                this.step = 0;
                this.arpeggioNotes = [];
                this.activeOscillators = [];
            }

            start() {
                this.isPlaying = true;
                this.scheduleNext();
            }

            stop() {
                this.isPlaying = false;
                this.activeOscillators.forEach(osc => {
                    try { osc.stop(); } catch(e) {}
                });
                this.activeOscillators = [];
            }

            scheduleNext() {
                if (!this.isPlaying) return;

                const tempo = parseFloat(document.getElementById('tempo').value);
                const handData = smoothedHands.right;

                // Tempo variation based on hand position
                const tempoMod = 1 + (handData.x.value - 0.5) * 0.3;
                const intervalMs = (60 / (tempo * tempoMod) / 4) * 1000; // Sixteenth notes

                this.playStep();

                setTimeout(() => this.scheduleNext(), intervalMs);
            }

            playStep() {
                const handData = smoothedHands.right;
                const fingerCount = Math.round(handData.fingerCount.value);
                const yPos = handData.y.value;
                const depth = handData.z.value;
                const rotation = handData.rotation.value;
                const openness = handData.openness.value;

                // Generate arpeggio based on finger count (complexity)
                const complexity = Math.max(1, Math.min(7, fingerCount + 1));
                this.generateArpeggio(yPos, complexity);

                if (this.arpeggioNotes.length > 0 && openness > 0.3) {
                    const noteIndex = this.step % this.arpeggioNotes.length;
                    const freq = this.arpeggioNotes[noteIndex];

                    // Volume based on depth
                    const volume = 0.1 + depth * 0.15;

                    // Timbre based on rotation
                    this.playMelodyNote(freq, volume, rotation, openness);
                }

                this.step++;
            }

            generateArpeggio(yPos, complexity) {
                const scale = getScaleFrequencies(currentScale);

                // Start note based on y position
                const startIndex = Math.floor((1 - yPos) * (scale.length - complexity - 1));

                // Philip Glass additive pattern
                this.arpeggioNotes = [];
                for (let i = 0; i < complexity; i++) {
                    const idx = (startIndex + i) % scale.length;
                    this.arpeggioNotes.push(scale[idx]);
                }

                // Glass-style pattern variations
                const patternType = Math.floor(complexity / 2) % 4;
                switch (patternType) {
                    case 1: // Up-down
                        this.arpeggioNotes = [...this.arpeggioNotes, ...this.arpeggioNotes.slice(1, -1).reverse()];
                        break;
                    case 2: // Additive
                        const additive = [];
                        for (let i = 1; i <= this.arpeggioNotes.length; i++) {
                            additive.push(...this.arpeggioNotes.slice(0, i));
                        }
                        this.arpeggioNotes = additive.slice(0, 12);
                        break;
                    case 3: // Interlocking
                        const interlock = [];
                        for (let i = 0; i < this.arpeggioNotes.length; i++) {
                            interlock.push(this.arpeggioNotes[i]);
                            if (i % 2 === 0 && i + 1 < this.arpeggioNotes.length) {
                                interlock.push(this.arpeggioNotes[i + 1]);
                            }
                        }
                        this.arpeggioNotes = interlock;
                        break;
                }
            }

            playMelodyNote(freq, volume, rotation, openness) {
                const now = audioCtx.currentTime;

                // Horn/woodwind simulation with multiple oscillators
                const detune = rotation * 15; // Subtle detuning based on rotation

                // Main oscillator (clarinet-like)
                const osc1 = audioCtx.createOscillator();
                osc1.type = 'sine';
                osc1.frequency.value = freq;
                osc1.detune.value = detune;

                // Harmonic oscillator (horn-like overtone)
                const osc2 = audioCtx.createOscillator();
                osc2.type = 'triangle';
                osc2.frequency.value = freq * 2;
                osc2.detune.value = -detune;

                // Third harmonic for richness
                const osc3 = audioCtx.createOscillator();
                osc3.type = 'sine';
                osc3.frequency.value = freq * 3;

                // Vibrato LFO
                const vibrato = audioCtx.createOscillator();
                vibrato.type = 'sine';
                vibrato.frequency.value = 5 + rotation * 2;

                const vibratoGain = audioCtx.createGain();
                vibratoGain.gain.value = 3 + openness * 5;

                vibrato.connect(vibratoGain);
                vibratoGain.connect(osc1.frequency);
                vibratoGain.connect(osc2.frequency);

                // Filter for timbre
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1500 + openness * 2000 + rotation * 500;
                filter.Q.value = 1 + openness * 2;

                // Gains
                const gain1 = audioCtx.createGain();
                const gain2 = audioCtx.createGain();
                const gain3 = audioCtx.createGain();

                gain1.gain.value = 1;
                gain2.gain.value = 0.3;
                gain3.gain.value = 0.1;

                // Envelope
                const envelope = audioCtx.createGain();
                const attackTime = 0.02 + (1 - openness) * 0.05;
                const releaseTime = 0.1 + openness * 0.2;

                envelope.gain.setValueAtTime(0, now);
                envelope.gain.linearRampToValueAtTime(volume, now + attackTime);
                envelope.gain.setValueAtTime(volume, now + attackTime + 0.05);
                envelope.gain.exponentialRampToValueAtTime(0.001, now + attackTime + releaseTime);

                // Connect
                osc1.connect(gain1);
                osc2.connect(gain2);
                osc3.connect(gain3);

                gain1.connect(filter);
                gain2.connect(filter);
                gain3.connect(filter);

                filter.connect(envelope);
                envelope.connect(masterGain);

                // Start and stop
                const stopTime = now + attackTime + releaseTime + 0.05;

                [osc1, osc2, osc3, vibrato].forEach(o => {
                    o.start(now);
                    o.stop(stopTime);
                    this.activeOscillators.push(o);
                });

                // Cleanup old oscillators
                setTimeout(() => {
                    this.activeOscillators = this.activeOscillators.filter(o => {
                        try {
                            return o.context.currentTime < stopTime;
                        } catch {
                            return false;
                        }
                    });
                }, (stopTime - now) * 1000 + 100);
            }
        }

        // ============================================
        // CHORD PAD (for grand moments)
        // ============================================
        class ChordPad {
            constructor() {
                this.activeNotes = [];
                this.lastChordTime = 0;
            }

            playChord(rootFreq, voicing, volume) {
                const now = audioCtx.currentTime;
                if (now - this.lastChordTime < 0.5) return; // Debounce
                this.lastChordTime = now;

                // Stop previous chord
                this.activeNotes.forEach(n => {
                    n.gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                });
                this.activeNotes = [];

                const scale = getScaleFrequencies(currentScale);
                const rootIndex = scale.findIndex(f => Math.abs(f - rootFreq) < 10) || 0;

                // Build chord based on voicing complexity
                const intervals = [0, 2, 4]; // Basic triad
                if (voicing >= 3) intervals.push(6); // 7th
                if (voicing >= 4) intervals.push(1, 3); // Add tensions
                if (voicing >= 5) intervals.push(5, 7); // Full orchestral

                intervals.forEach((interval, i) => {
                    const noteIndex = (rootIndex + interval) % scale.length;
                    let freq = scale[noteIndex];

                    // Spread across octaves
                    if (i > 3) freq *= 2;
                    if (i > 5) freq *= 2;

                    const noteData = this.createPadNote(freq, volume * 0.7, now);
                    this.activeNotes.push(noteData);
                });
            }

            createPadNote(freq, volume, startTime) {
                const osc = audioCtx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = freq;

                const osc2 = audioCtx.createOscillator();
                osc2.type = 'triangle';
                osc2.frequency.value = freq;
                osc2.detune.value = 5;

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;

                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(volume, startTime + 0.5);

                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);

                osc.start(startTime);
                osc2.start(startTime);

                return { osc, osc2, gain, filter };
            }

            release() {
                const now = audioCtx.currentTime;
                this.activeNotes.forEach(n => {
                    n.gain.gain.exponentialRampToValueAtTime(0.001, now + 1);
                    n.osc.stop(now + 1.1);
                    n.osc2.stop(now + 1.1);
                });
                this.activeNotes = [];
            }
        }

        let chordPad;

        // ============================================
        // MAIN LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();

            // Update particles based on hand data
            updateParticles(rhythmParticles, smoothedHands.left, true, time);
            updateParticles(melodyParticles, smoothedHands.right, false, time);

            // Move particle systems based on hand position
            if (hands.left) {
                rhythmParticles.position.x = (smoothedHands.left.x.value - 0.5) * 40 - 10;
                rhythmParticles.position.y = (0.5 - smoothedHands.left.y.value) * 30;
            }

            if (hands.right) {
                melodyParticles.position.x = (smoothedHands.right.x.value - 0.5) * 40 + 10;
                melodyParticles.position.y = (0.5 - smoothedHands.right.y.value) * 30;
            }

            // Rotate particles subtly
            rhythmParticles.rotation.y += 0.001;
            melodyParticles.rotation.y -= 0.001;

            // Camera breathing
            camera.position.z = 50 + Math.sin(time * 0.0005) * 3;

            // Check for grand chord trigger (both hands open and high)
            if (isPlaying && hands.left && hands.right) {
                const leftOpen = smoothedHands.left.openness.value > 0.7;
                const rightOpen = smoothedHands.right.openness.value > 0.7;
                const bothHigh = smoothedHands.left.y.value < 0.3 && smoothedHands.right.y.value < 0.3;

                if (leftOpen && rightOpen && bothHigh) {
                    const scale = getScaleFrequencies(currentScale);
                    const rootFreq = scale[Math.floor(scale.length / 2)];
                    const voicing = Math.round(
                        (smoothedHands.left.fingerCount.value + smoothedHands.right.fingerCount.value) / 2
                    );
                    const volume = (smoothedHands.left.z.value + smoothedHands.right.z.value) / 2;
                    chordPad.playChord(rootFreq, voicing, volume);
                }
            }

            renderer.render(scene, camera);

            // Draw hand visualization on overlay
            drawOverlay();
        }

        function drawOverlay() {
            const canvas = document.getElementById('overlay');
            const ctx = canvas.getContext('2d');

            if (canvas.width !== window.innerWidth) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw subtle hand position indicators
            if (hands.left) {
                const x = smoothedHands.left.x.value * canvas.width;
                const y = smoothedHands.left.y.value * canvas.height;
                const size = 20 + smoothedHands.left.openness.value * 30;

                ctx.strokeStyle = `rgba(255, 107, 107, ${0.3 + smoothedHands.left.openness.value * 0.4})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.stroke();

                // Finger indicators
                const fingers = Math.round(smoothedHands.left.fingerCount.value);
                for (let i = 0; i < fingers; i++) {
                    const angle = (i / 5) * Math.PI - Math.PI / 2;
                    const fx = x + Math.cos(angle) * (size + 10);
                    const fy = y + Math.sin(angle) * (size + 10);
                    ctx.beginPath();
                    ctx.arc(fx, fy, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 107, 107, 0.6)';
                    ctx.fill();
                }
            }

            if (hands.right) {
                const x = smoothedHands.right.x.value * canvas.width;
                const y = smoothedHands.right.y.value * canvas.height;
                const size = 20 + smoothedHands.right.openness.value * 30;

                ctx.strokeStyle = `rgba(78, 205, 196, ${0.3 + smoothedHands.right.openness.value * 0.4})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.stroke();

                // Finger indicators
                const fingers = Math.round(smoothedHands.right.fingerCount.value);
                for (let i = 0; i < fingers; i++) {
                    const angle = (i / 5) * Math.PI - Math.PI / 2;
                    const fx = x + Math.cos(angle) * (size + 10);
                    const fy = y + Math.sin(angle) * (size + 10);
                    ctx.beginPath();
                    ctx.arc(fx, fy, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(78, 205, 196, 0.6)';
                    ctx.fill();
                }
            }
        }

        // ============================================
        // CONTROLS
        // ============================================
        function setupControls() {
            document.getElementById('startBtn').addEventListener('click', startConducting);
            document.getElementById('stopBtn').addEventListener('click', stopConducting);

            document.getElementById('masterVolume').addEventListener('input', (e) => {
                if (masterGain) {
                    masterGain.gain.setTargetAtTime(parseFloat(e.target.value), audioCtx.currentTime, 0.1);
                }
            });

            document.getElementById('tempo').addEventListener('input', (e) => {
                tempo = parseInt(e.target.value);
                document.getElementById('tempoValue').textContent = tempo;
            });

            document.getElementById('scaleSelect').addEventListener('change', (e) => {
                currentScale = e.target.value;
            });
        }

        async function startConducting() {
            if (isPlaying) return;

            if (!audioCtx) {
                initAudio();
            }

            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }

            isPlaying = true;

            // Start sequencers
            rhythmSequencer = new RhythmSequencer();
            melodyArpeggiator = new MelodyArpeggiator();
            chordPad = new ChordPad();

            rhythmSequencer.start();
            melodyArpeggiator.start();

            updateStatus('Conducting... Move your hands!');
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'inline-block';
        }

        function stopConducting() {
            isPlaying = false;

            if (rhythmSequencer) rhythmSequencer.stop();
            if (melodyArpeggiator) melodyArpeggiator.stop();
            if (chordPad) chordPad.release();

            updateStatus('Stopped. Click "Begin Conducting" to start again.');
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'none';
        }

        function updateStatus(message) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.classList.remove('loading');
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            updateStatus('Initializing 3D engine...');
            initThreeJS();

            updateStatus('Setting up controls...');
            setupControls();
            document.getElementById('stopBtn').style.display = 'none';

            updateStatus('Starting hand tracking...');
            await initHandTracking();

            // Start render loop
            animate();
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
