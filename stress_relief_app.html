<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Breathe - Stress Relief</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .setup-screen {
            text-align: center;
            color: white;
            z-index: 10;
        }

        .setup-screen h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 1rem;
            opacity: 0.9;
        }

        .setup-screen p {
            font-size: 1.1rem;
            margin-bottom: 2rem;
            opacity: 0.8;
            line-height: 1.6;
            max-width: 300px;
        }

        .session-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .session-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 80px;
        }

        .session-btn:hover, .session-btn.selected {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        .start-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
            border: none;
            padding: 15px 40px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px;
        }

        .start-btn:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .start-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .session-screen {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .pulse-display {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.1rem;
            font-weight: 300;
        }

        .ekg-container {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 80px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
            backdrop-filter: blur(10px);
        }

        .ekg-display {
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        .ekg-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .signal-quality {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .signal-good {
            color: #4ade80;
        }

        .signal-poor {
            color: #fb7185;
        }

        .breathing-guide {
            width: 200px;
            height: 200px;
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease-out;
        }

        .breathing-guide::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            transition: all 0.1s ease-out;
        }

        .breathing-text {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2rem;
            font-weight: 300;
            z-index: 1;
        }

        .session-info {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
        }

        .time-remaining {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .wave-score {
            font-size: 1rem;
        }

        .completion-screen {
            display: none;
            text-align: center;
            color: white;
            z-index: 10;
        }

        .completion-screen h2 {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 1rem;
            opacity: 0.9;
        }

        .completion-screen p {
            font-size: 1.1rem;
            margin-bottom: 2rem;
            opacity: 0.8;
            line-height: 1.6;
        }

        .video-container {
            position: absolute;
            top: -9999px;
            left: -9999px;
            opacity: 0;
        }

        .video-feed {
            width: 50px;
            height: 50px;
        }

        .canvas-debug {
            width: 50px;
            height: 50px;
        }

        .instruction-text {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            text-align: center;
            max-width: 280px;
            line-height: 1.4;
        }

        @media (max-width: 480px) {
            .setup-screen h1 {
                font-size: 2rem;
            }
            
            .breathing-guide {
                width: 180px;
                height: 180px;
            }
            
            .session-buttons {
                gap: 10px;
            }
            
            .session-btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .breathing-guide {
                width: 150px;
                height: 150px;
            }
            
            .pulse-display {
                top: 10px;
            }
            
            .ekg-container {
                top: 40px;
                width: 250px;
                height: 60px;
            }
            
            .session-info {
                bottom: 20px;
            }
        }

        @media (max-width: 480px) {
            .ekg-container {
                width: 280px;
            }
        }

        .signal-fair {
            color: #fbbf24;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="setup-screen" id="setupScreen">
            <h1>Breathe</h1>
            <p>Find your calm with guided breathing based on your natural rhythm</p>
            
            <div class="session-buttons">
                <button class="session-btn" data-duration="60">1 min</button>
                <button class="session-btn selected" data-duration="180">3 min</button>
                <button class="session-btn" data-duration="300">5 min</button>
            </div>
            
            <button class="start-btn" id="startBtn">Begin Session</button>
            
            <p style="font-size: 0.9rem; margin-top: 1.5rem; opacity: 0.7;">
                Place your fingertip over the rear camera when prompted
            </p>
        </div>

        <div class="session-screen" id="sessionScreen">
            <div class="pulse-display" id="pulseDisplay">
                Detecting pulse...
            </div>
            
            <div class="ekg-container">
                <div class="ekg-display">
                    <canvas id="ekgCanvas" class="ekg-canvas"></canvas>
                    <div class="signal-quality" id="signalQuality">Waiting for signal...</div>
                </div>
            </div>
            
            <div class="breathing-guide" id="breathingGuide">
                <div class="breathing-text" id="breathingText">Place finger on camera</div>
            </div>
            
            <div class="instruction-text" id="instructionText">
                Gently place your fingertip over the rear camera and flash. Keep it steady and relaxed.
            </div>
            
            <div class="session-info">
                <div class="time-remaining" id="timeRemaining">3:00</div>
                <div class="wave-score" id="waveScore">Finding your rhythm...</div>
            </div>
        </div>

        <div class="completion-screen" id="completionScreen">
            <h2>Well Done</h2>
            <p>You've completed your breathing session. Take a moment to notice how you feel.</p>
            <button class="start-btn" onclick="resetApp()">New Session</button>
        </div>

        <div class="video-container">
            <video id="videoFeed" class="video-feed" autoplay muted playsinline></video>
            <canvas id="canvas" class="canvas-debug"></canvas>
        </div>
    </div>

    <script>
        class StressReliefApp {
            constructor() {
                this.selectedDuration = 180; // Default 3 minutes
                this.stream = null;
                this.track = null;
                this.pulseData = [];
                this.lastBeatTime = 0;
                this.currentBPM = 0;
                this.hrvData = [];
                this.breathingRate = 6; // breaths per minute
                this.sessionStartTime = 0;
                this.sessionDuration = 180;
                this.animationId = null;
                this.isSessionActive = false;
                this.pulseDetectionActive = false;
                this.breathingPhase = 'inhale'; // 'inhale' or 'exhale'
                this.breathingStartTime = 0;
                this.waveScore = 0;
                this.pulseHistory = [];
                this.smoothedBPM = 0;
                this.ekgData = [];
                this.ekgCanvas = null;
                this.ekgCtx = null;
                this.signalQuality = 'poor';
                this.goodSignalStartTime = 0;
                this.breathingStarted = false;
                this.rawIntensityHistory = [];
                this.bpmHistory = [];
                this.stableBreathingRate = 6; // stable rate, updated slowly
                this.breathingCycleStartTime = 0;
                
                this.initializeApp();
            }

            initializeApp() {
                this.setupEventListeners();
                this.setupSessionButtons();
            }

            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startSession();
                });

                // Handle visibility change to manage camera properly
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.isSessionActive) {
                        this.pauseSession();
                    }
                });
            }

            setupSessionButtons() {
                const buttons = document.querySelectorAll('.session-btn');
                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        buttons.forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        this.selectedDuration = parseInt(btn.dataset.duration);
                    });
                });
            }

            async startSession() {
                try {
                    await this.requestCameraAccess();
                    this.showSessionScreen();
                    this.sessionStartTime = Date.now();
                    this.sessionDuration = this.selectedDuration;
                    this.isSessionActive = true;
                    this.startPulseDetection();
                    this.startSessionLoop();
                } catch (error) {
                    console.error('Failed to start session:', error);
                    alert('Unable to access camera. Please ensure camera permissions are granted and try again.');
                }
            }

            async requestCameraAccess() {
                const video = document.getElementById('videoFeed');
                
                // Request rear camera with flash capability
                const constraints = {
                    video: {
                        facingMode: 'environment', // Rear camera
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };

                try {
                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = this.stream;
                    
                    // Get video track to control flash
                    this.track = this.stream.getVideoTracks()[0];
                    
                    // Try to turn on flash/torch
                    if (this.track && 'applyConstraints' in this.track) {
                        try {
                            await this.track.applyConstraints({
                                advanced: [{ torch: true }]
                            });
                        } catch (e) {
                            console.log('Flash not available:', e);
                        }
                    }

                    return new Promise((resolve) => {
                        video.onloadedmetadata = () => {
                            video.play();
                            resolve();
                        };
                    });
                } catch (error) {
                    throw new Error('Camera access denied or not available');
                }
            }

            showSessionScreen() {
                document.getElementById('setupScreen').style.display = 'none';
                document.getElementById('sessionScreen').style.display = 'flex';
                this.initializeEKG();
                this.updateTimeDisplay();
            }

            initializeEKG() {
                this.ekgCanvas = document.getElementById('ekgCanvas');
                this.ekgCtx = this.ekgCanvas.getContext('2d');
                
                // Set canvas size
                const rect = this.ekgCanvas.getBoundingClientRect();
                this.ekgCanvas.width = rect.width * window.devicePixelRatio;
                this.ekgCanvas.height = rect.height * window.devicePixelRatio;
                this.ekgCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                // Set drawing style
                this.ekgCtx.strokeStyle = '#4ade80';
                this.ekgCtx.lineWidth = 2;
                this.ekgCtx.lineCap = 'round';
            }

            startPulseDetection() {
                const video = document.getElementById('videoFeed');
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = 50;
                canvas.height = 50;
                
                this.pulseDetectionActive = true;
                
                const detectPulse = () => {
                    if (!this.pulseDetectionActive) return;
                    
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        ctx.drawImage(video, 0, 0, 50, 50);
                        const imageData = ctx.getImageData(0, 0, 50, 50);
                        const avgIntensity = this.calculateAverageIntensity(imageData);
                        
                        this.processPulseData(avgIntensity);
                    }
                    
                    setTimeout(detectPulse, 50); // 20 FPS for pulse detection
                };
                
                detectPulse();
            }

            calculateAverageIntensity(imageData) {
                const data = imageData.data;
                let sum = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Use red channel as it's most sensitive to blood flow
                    sum += data[i];
                }
                
                return sum / (data.length / 4);
            }

            processPulseData(intensity) {
                const timestamp = Date.now();
                this.pulseData.push({ intensity, timestamp });
                
                // Add to raw intensity history for EKG display
                this.rawIntensityHistory.push(intensity);
                if (this.rawIntensityHistory.length > 300) {
                    this.rawIntensityHistory.shift();
                }
                
                // Update EKG display
                this.updateEKGDisplay();
                
                // Keep only last 3 seconds of data for analysis
                this.pulseData = this.pulseData.filter(d => timestamp - d.timestamp < 3000);
                
                if (this.pulseData.length < 20) return; // Need minimum data
                
                // Analyze signal quality
                this.analyzeSignalQuality();
                
                // Only proceed with pulse detection if we have good signal
                if (this.signalQuality !== 'good') return;
                
                // Detect peaks in intensity (pulse beats)
                const peaks = this.detectPeaks(this.pulseData.map(d => d.intensity));
                
                if (peaks.length >= 2) {
                    const intervals = [];
                    for (let i = 1; i < peaks.length; i++) {
                        const interval = this.pulseData[peaks[i]].timestamp - this.pulseData[peaks[i-1]].timestamp;
                        if (interval > 300 && interval < 2000) { // Valid heart rate range
                            intervals.push(interval);
                        }
                    }
                    
                    if (intervals.length > 0) {
                        const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                        const bpm = Math.round(60000 / avgInterval);
                        
                        if (bpm >= 50 && bpm <= 120) {
                            this.updateBPM(bpm);
                            this.calculateHRV(intervals);
                            this.checkIfReadyForBreathing();
                        }
                    }
                }
            }

            updateEKGDisplay() {
                if (!this.ekgCtx || this.rawIntensityHistory.length < 2) return;
                
                const canvas = this.ekgCanvas;
                const ctx = this.ekgCtx;
                const width = canvas.width / window.devicePixelRatio;
                const height = canvas.height / window.devicePixelRatio;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i < width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, height);
                    ctx.stroke();
                }
                for (let i = 0; i < height; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(width, i);
                    ctx.stroke();
                }
                
                // Normalize intensity data
                const recentData = this.rawIntensityHistory.slice(-Math.floor(width));
                if (recentData.length < 2) return;
                
                const min = Math.min(...recentData);
                const max = Math.max(...recentData);
                const range = max - min || 1;
                
                // Draw EKG waveform
                ctx.strokeStyle = this.signalQuality === 'good' ? '#4ade80' : 
                                 this.signalQuality === 'fair' ? '#fbbf24' : '#fb7185';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < recentData.length; i++) {
                    const x = (i / recentData.length) * width;
                    const normalizedValue = (recentData[i] - min) / range;
                    const y = height - (normalizedValue * height * 0.8) - height * 0.1;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }

            analyzeSignalQuality() {
                if (this.rawIntensityHistory.length < 50) {
                    this.signalQuality = 'poor';
                    return;
                }
                
                const recentData = this.rawIntensityHistory.slice(-50);
                const mean = recentData.reduce((a, b) => a + b) / recentData.length;
                const min = Math.min(...recentData);
                const max = Math.max(...recentData);
                const range = max - min;
                
                // PPG signals have small amplitude changes - look for consistent variation
                const variance = recentData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recentData.length;
                const stdDev = Math.sqrt(variance);
                
                // Calculate AC/DC ratio (more appropriate for PPG)
                const acComponent = stdDev;
                const dcComponent = mean;
                const acDcRatio = (acComponent / dcComponent) * 100;
                
                // Check for periodic variation (pulse-like pattern)
                let peaks = 0;
                for (let i = 1; i < recentData.length - 1; i++) {
                    if (recentData[i] > recentData[i-1] && recentData[i] > recentData[i+1] && 
                        recentData[i] > mean + stdDev * 0.5) {
                        peaks++;
                    }
                }
                
                const peakRate = peaks / (recentData.length / 10); // peaks per 10 samples
                
                // PPG-specific quality criteria
                let quality = 'poor';
                
                if (range > 0.5 && acDcRatio > 0.01 && peakRate > 0.5 && peakRate < 3) {
                    // Good: visible variation, reasonable AC/DC ratio, pulse-like peaks
                    quality = 'good';
                } else if (range > 0.2 && acDcRatio > 0.005 && stdDev > 0.1) {
                    // Fair: some variation present
                    quality = 'fair';
                }
                
                this.signalQuality = quality;
                
                // Update signal quality display
                const qualityElement = document.getElementById('signalQuality');
                qualityElement.textContent = `Signal: ${this.signalQuality.toUpperCase()}`;
                qualityElement.className = `signal-quality signal-${this.signalQuality}`;
                
                // Debug info (can remove later)
                console.log(`PPG Quality: ${quality}, Range: ${range.toFixed(2)}, AC/DC: ${acDcRatio.toFixed(4)}%, Peaks: ${peaks}, StdDev: ${stdDev.toFixed(2)}`);
            }

            checkIfReadyForBreathing() {
                if (this.breathingStarted) return;
                
                const now = Date.now();
                
                if (this.signalQuality === 'good' && this.smoothedBPM > 0) {
                    if (this.goodSignalStartTime === 0) {
                        this.goodSignalStartTime = now;
                    } else if (now - this.goodSignalStartTime > 3000) { // 3 seconds of good signal
                        this.startBreathingGuidance();
                    }
                } else {
                    this.goodSignalStartTime = 0;
                }
            }

            startBreathingGuidance() {
                this.breathingStarted = true;
                this.breathingCycleStartTime = Date.now();
                document.getElementById('breathingText').textContent = 'Ready';
                document.getElementById('instructionText').textContent = 'Great! Now follow the breathing guide';
            }

            detectPeaks(data) {
                const peaks = [];
                const threshold = Math.max(...data) * 0.8; // 80% of max value
                
                for (let i = 1; i < data.length - 1; i++) {
                    if (data[i] > data[i-1] && data[i] > data[i+1] && data[i] > threshold) {
                        peaks.push(i);
                    }
                }
                
                return peaks;
            }

            updateBPM(bpm) {
                this.pulseHistory.push(bpm);
                if (this.pulseHistory.length > 5) {
                    this.pulseHistory.shift();
                }
                
                // Smooth BPM reading with more aggressive averaging
                this.smoothedBPM = Math.round(
                    this.pulseHistory.reduce((a, b) => a + b) / this.pulseHistory.length
                );
                
                // Keep longer history for breathing rate calculation
                this.bpmHistory.push(this.smoothedBPM);
                if (this.bpmHistory.length > 20) {
                    this.bpmHistory.shift();
                }
                
                document.getElementById('pulseDisplay').textContent = `❤️ ${this.smoothedBPM} BPM`;
                
                // Update stable breathing rate much more slowly and smoothly
                this.updateStableBreathingRate();
            }
            
            updateStableBreathingRate() {
                if (this.bpmHistory.length < 5) return;
                
                // Calculate very stable average BPM over longer period
                const longTermBPM = this.bpmHistory.reduce((a, b) => a + b) / this.bpmHistory.length;
                
                // Calculate target breathing rate based on StressEraser method
                // Typically 4.5-7 breaths per minute, based on heart rate variability resonance
                const targetRate = Math.max(4.5, Math.min(7, longTermBPM * 0.08));
                
                // Very slow adjustment toward target - prevents jerky changes
                const adjustment = (targetRate - this.stableBreathingRate) * 0.05; // 5% adjustment
                this.stableBreathingRate += adjustment;
                
                // Clamp to reasonable range
                this.stableBreathingRate = Math.max(4, Math.min(8, this.stableBreathingRate));
            }

            calculateHRV(intervals) {
                if (intervals.length < 3) return;
                
                const differences = [];
                for (let i = 1; i < intervals.length; i++) {
                    differences.push(Math.abs(intervals[i] - intervals[i-1]));
                }
                
                const rmssd = Math.sqrt(
                    differences.reduce((sum, diff) => sum + diff * diff, 0) / differences.length
                );
                
                this.hrvData.push(rmssd);
                if (this.hrvData.length > 10) {
                    this.hrvData.shift();
                }
                
                // Update wave score based on HRV coherence
                this.updateWaveScore();
            }

            updateWaveScore() {
                if (this.hrvData.length < 5) return;
                
                const avgHRV = this.hrvData.reduce((a, b) => a + b) / this.hrvData.length;
                const variability = Math.sqrt(
                    this.hrvData.reduce((sum, val) => sum + Math.pow(val - avgHRV, 2), 0) / this.hrvData.length
                );
                
                // Lower variability = better coherence = higher score
                const coherenceScore = Math.max(0, Math.min(100, (50 - variability) * 2));
                this.waveScore = Math.round(coherenceScore);
                
                document.getElementById('waveScore').textContent = `Coherence: ${this.waveScore}%`;
            }

            startSessionLoop() {
                const loop = () => {
                    if (!this.isSessionActive) return;
                    
                    const elapsed = (Date.now() - this.sessionStartTime) / 1000;
                    const remaining = Math.max(0, this.sessionDuration - elapsed);
                    
                    this.updateTimeDisplay(remaining);
                    this.updateBreathingGuide();
                    
                    if (remaining <= 0) {
                        this.completeSession();
                        return;
                    }
                    
                    this.animationId = requestAnimationFrame(loop);
                };
                
                loop();
            }

            updateTimeDisplay(remaining = null) {
                if (remaining === null) {
                    remaining = this.sessionDuration;
                }
                
                const minutes = Math.floor(remaining / 60);
                const seconds = Math.floor(remaining % 60);
                document.getElementById('timeRemaining').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            updateBreathingGuide() {
                if (!this.breathingStarted) {
                    // Show pulse detection status
                    const guide = document.getElementById('breathingGuide');
                    const text = document.getElementById('breathingText');
                    
                    if (this.signalQuality === 'good' && this.smoothedBPM > 0) {
                        const timeLeft = Math.max(0, 3 - (Date.now() - this.goodSignalStartTime) / 1000);
                        text.textContent = `Good signal! ${Math.ceil(timeLeft)}s`;
                        guide.style.transform = 'scale(1.1)';
                        guide.style.opacity = '0.8';
                    } else {
                        text.textContent = this.signalQuality === 'poor' ? 'Place finger on camera' : 
                                          this.signalQuality === 'fair' ? 'Adjusting...' : 'Detecting...';
                        guide.style.transform = 'scale(1)';
                        guide.style.opacity = '0.6';
                    }
                    return;
                }
                
                if (this.smoothedBPM === 0) return;
                
                // Use stable breathing rate for smooth, consistent timing
                const breathingCycleDuration = (60 / this.stableBreathingRate) * 1000; // ms per breath
                const inhaleRatio = 0.4; // 40% inhale, 60% exhale (StressEraser method)
                
                // Use consistent cycle timing from when breathing started
                const elapsedTime = Date.now() - this.breathingCycleStartTime;
                const cyclePosition = (elapsedTime % breathingCycleDuration) / breathingCycleDuration;
                const guide = document.getElementById('breathingGuide');
                const text = document.getElementById('breathingText');
                const instruction = document.getElementById('instructionText');
                
                let scale, opacity, breathingText, instructionText;
                
                if (cyclePosition < inhaleRatio) {
                    // Inhale phase
                    const inhaleProgress = cyclePosition / inhaleRatio;
                    scale = 1 + (inhaleProgress * 0.5); // Expand to 150%
                    opacity = 0.1 + (inhaleProgress * 0.2);
                    breathingText = 'Inhale';
                    instructionText = 'Breathe in slowly and naturally';
                    this.breathingPhase = 'inhale';
                } else {
                    // Exhale phase
                    const exhaleProgress = (cyclePosition - inhaleRatio) / (1 - inhaleRatio);
                    scale = 1.5 - (exhaleProgress * 0.5); // Contract back to 100%
                    opacity = 0.3 - (exhaleProgress * 0.2);
                    breathingText = 'Exhale';
                    instructionText = 'Release slowly and completely';
                    this.breathingPhase = 'exhale';
                }
                
                guide.style.transform = `scale(${scale})`;
                guide.style.opacity = opacity + 0.6;
                text.textContent = breathingText;
                instruction.textContent = instructionText;
            }

            completeSession() {
                this.isSessionActive = false;
                this.pulseDetectionActive = false;
                
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                this.stopCamera();
                this.showCompletionScreen();
            }

            stopCamera() {
                if (this.track) {
                    // Turn off flash
                    try {
                        this.track.applyConstraints({
                            advanced: [{ torch: false }]
                        });
                    } catch (e) {
                        console.log('Could not turn off flash:', e);
                    }
                    
                    this.track.stop();
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
            }

            showCompletionScreen() {
                document.getElementById('sessionScreen').style.display = 'none';
                document.getElementById('completionScreen').style.display = 'flex';
            }

            pauseSession() {
                this.isSessionActive = false;
                this.pulseDetectionActive = false;
                this.stopCamera();
            }
        }

        // Initialize app when page loads
        let app;
        
        function resetApp() {
            if (app) {
                app.stopCamera();
            }
            
            document.getElementById('completionScreen').style.display = 'none';
            document.getElementById('sessionScreen').style.display = 'none';
            document.getElementById('setupScreen').style.display = 'block';
            
            app = new StressReliefApp();
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', () => {
            app = new StressReliefApp();
        });

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (app) {
                app.stopCamera();
            }
        });
    </script>
</body>
</html>