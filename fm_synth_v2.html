<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>FM Synth v2 - Rhythmic FM Synthesis</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:black; color:white; }
  #controls {
    position:absolute; top:10px; left:10px;
    background:rgba(0,0,0,0.8); padding:15px; border-radius:10px;
    font-family:sans-serif; z-index:5; max-width:450px;
    border: 2px solid #333;
    backdrop-filter: blur(10px);
    max-height: 90vh;
    overflow-y: auto;
    transition: transform 0.3s ease;
  }
  #controls.collapsed {
    transform: translateX(-85%);
  }
  #controls.collapsed:hover {
    transform: translateX(-5%);
  }
  .main-collapse-btn {
    position: absolute;
    top: 10px;
    right: -40px;
    background: rgba(0,0,0,0.8);
    border: 2px solid #333;
    color: white;
    padding: 8px 12px;
    border-radius: 0 10px 10px 0;
    cursor: pointer;
    font-size: 16px;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }
  .main-collapse-btn:hover {
    background: rgba(50,50,50,0.9);
  }
  #controls label { display:block; margin-top:8px; font-size:12px; }
  #controls input[type="range"] { width:100%; }
  #controls select { width:100%; margin-top:4px; }
  
  
  /* Collapsible Panel Styles */
  .panel-header {
    background: rgba(50,50,50,0.8);
    padding: 10px;
    border-radius: 5px;
    margin: 8px 0 4px 0;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border: 1px solid #555;
    transition: background-color 0.3s;
  }
  .panel-header:hover {
    background: rgba(70,70,70,0.8);
  }
  .panel-header.collapsed {
    margin-bottom: 8px;
  }
  .panel-content {
    margin-left: 10px;
    border-left: 2px solid #555;
    padding-left: 10px;
    transition: max-height 0.3s ease;
    overflow: hidden;
  }
  .panel-content.collapsed {
    max-height: 0;
    padding: 0 0 0 10px;
    margin: 0;
  }
  .panel-arrow {
    transition: transform 0.3s;
    font-size: 14px;
  }
  .panel-arrow.collapsed {
    transform: rotate(-90deg);
  }
  
  canvas { position:absolute; top:0; left:0; width:100%; height:100%; }
  .status-indicator {
    display: inline-block; width: 12px; height: 12px; border-radius: 50%;
    margin-right: 8px; background: #ff4444;
  }
  .status-indicator.active { background: #44ff44; }
  .hand-info {
    background: rgba(255,255,255,0.1); padding: 8px; border-radius: 5px;
    margin-top: 10px; font-size: 11px;
  }
  .progress { background: rgba(255,255,255,0.2); padding: 5px; border-radius: 3px; margin-top: 5px; }
  .gesture-status {
    background: rgba(100,255,100,0.2); padding: 8px; border-radius: 5px;
    margin-top: 10px; font-size: 12px; border: 1px solid #4f4;
  }
  .active-sounds {
    background: rgba(255,200,0,0.2); padding: 6px; border-radius: 5px;
    margin-top: 8px; font-size: 11px; border: 1px solid #fc0;
  }
  .visual-controls {
    background: rgba(255,0,255,0.2); padding: 8px; border-radius: 5px;
    margin-top: 8px; font-size: 11px; border: 1px solid #f0f;
  }
</style>
</head>
<body>
<div id="controls">
  <button class="main-collapse-btn" id="main-collapse-btn">‚óÄ</button>
  <div style="display: flex; align-items: center; margin-bottom: 10px;">
    <h2 style="margin: 0; flex: 1;">ü•Å FM Synth v2</h2>
    <div class="status-indicator" id="model-status"></div>
  </div>
  

  
  <!-- System Info Panel -->
  <div class="panel-header" id="system-header">
    <span>üéõÔ∏è FM Synthesizer Information</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="system-panel">
    <div class="hand-info">
      <div>ü•Å <strong>FM Synth v2:</strong> Rhythmic FM Synthesis</div>
      <div id="hand-detection-status">Loading ML5.js HandPose model...</div>
      <div class="progress">
        ‚úÖ Gesture-controlled FM synthesis<br>
        ‚úÖ Carrier + Modulator oscillators<br>
        ‚úÖ Real-time modulation mapping<br>
        ‚úÖ Musical scale integration<br>
        ‚úÖ Rhythmic beat sequencer<br>
        ‚úÖ Gate effects synchronization
      </div>
    </div>
  </div>

  <!-- FM Synthesis Controls Panel -->
  <div class="panel-header" id="fm-header">
    <span>üì° FM Synthesis Engine</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="fm-panel">
    <div class="visual-controls" style="border-color: #f84;">
      <strong>üéõÔ∏è FM Parameters:</strong><br>
      <label>Carrier Ratio: <span id="carrierRatioVal">1.0</span>
        <input type="range" id="carrierRatio" min="0.5" max="4.0" step="0.1" value="1.0">
      </label>
      <label>Modulator Ratio: <span id="modulatorRatioVal">1.0</span>
        <input type="range" id="modulatorRatio" min="0.1" max="8.0" step="0.1" value="1.0">
      </label>
      <label>Modulation Index: <span id="modulationIndexVal">2.0</span>
        <input type="range" id="modulationIndex" min="0" max="10" step="0.1" value="2.0">
      </label>
      <label>Feedback Amount: <span id="feedbackVal">0.0</span>
        <input type="range" id="feedback" min="0" max="0.9" step="0.05" value="0.0">
      </label>
    </div>
  </div>

  <!-- Gesture Controls Panel -->
  <div class="panel-header" id="gesture-header">
    <span>ü§ö FM Gesture Mapping</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="gesture-panel">
    <div class="gesture-status">
             <strong>ü§ö Left Hand (Carrier Control):</strong><br>
       ‚Ä¢ X-axis: Modulation index<br>
       ‚Ä¢ Y-axis: Carrier frequency<br>
       ‚Ä¢ Distance: Master volume<br>
       ‚Ä¢ Fingers: Vibrato depth (1=none, 5=deep vibrato)<br>
       <br>
       <strong>üëâ Right Hand (Modulator Control):</strong><br>
       ‚Ä¢ X-axis: Feedback amount<br>
       ‚Ä¢ Y-axis: Modulator frequency ratio<br>
       ‚Ä¢ Distance: Modulator amplitude<br>
       ‚Ä¢ Fingers: FM operator count (1=simple, 5=complex)<br>
      <div id="gesture-feedback">Show hands to see FM parameters...</div>
    </div>

    <div class="active-sounds">
      <strong>üéµ Active FM Operators:</strong>
      <div id="sound-layers">None</div>
    </div>
  </div>

  <!-- Musical Scale Panel -->
  <div class="panel-header" id="scale-header">
    <span>üéº Musical Scales</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="scale-panel">
    <label>Scale Type:
      <select id="scaleType">
        <option value="chromatic">Chromatic (All Notes)</option>
        <option value="major" selected>Major Scale</option>
        <option value="minor">Minor Scale</option>
        <option value="pentatonic">Pentatonic</option>
        <option value="colundi">Colundi (Modal)</option>
      </select>
    </label>
    <label>Root Note:
      <select id="rootNote">
        <option value="C">C</option>
        <option value="C#">C# / Db</option>
        <option value="D">D</option>
        <option value="D#">D# / Eb</option>
        <option value="E">E</option>
        <option value="F">F</option>
        <option value="F#">F# / Gb</option>
        <option value="G">G</option>
        <option value="G#">G# / Ab</option>
        <option value="A" selected>A</option>
        <option value="A#">A# / Bb</option>
        <option value="B">B</option>
      </select>
    </label>
    <div id="scale-info" style="font-size: 10px; color: #aaa; margin-top: 5px;">
      Current scale: A Major
    </div>
  </div>

  <!-- Visual Effects Panel -->
  <div class="panel-header" id="visual-header">
    <span>üåà Visual Effects</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="visual-panel">
    <div class="visual-controls">
      <strong>üåà Visual Effects:</strong><br>
      <label>Effect Intensity: <span id="effectIntensityVal">0.7</span>
        <input type="range" id="effectIntensity" min="0.1" max="1" step="0.1" value="0.7">
      </label>
      <label>Hand Glow Size: <span id="handGlowVal">30</span>
        <input type="range" id="handGlow" min="10" max="60" step="5" value="30">
      </label>
    </div>

    <div class="visual-controls" style="border-color: #0ff;">
      <strong>üìè Volume Calibration:</strong><br>
      <label>Close Hand Distance (100% vol): <span id="maxDistanceVal">120</span>
        <input type="range" id="maxDistance" min="100" max="800" step="10" value="120">
      </label>
      <label>Far Hand Distance (0% vol): <span id="minDistanceVal">40</span>
        <input type="range" id="minDistance" min="10" max="200" step="5" value="40">
      </label>
      <div id="distance-debug" style="font-size: 10px; color: #0ff; margin-top: 5px;">
        Current distances will appear here...
      </div>
    </div>
  </div>



  <!-- Left Hand Controls Panel -->
  <div class="panel-header" id="left-header">
    <span>üëà Left Hand - Carrier Oscillator</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="left-panel">
    <label>Carrier Waveform:
      <select id="leftWaveform">
        <option value="sine" selected>Sine Wave</option>
        <option value="triangle">Triangle Wave</option>
        <option value="sawtooth">Sawtooth Wave</option>
        <option value="square">Square Wave</option>
      </select>
    </label>
    <label>Base Frequency: <span id="leftBasePitchVal">220</span> Hz
      <input type="range" id="leftBasePitch" min="80" max="800" value="220">
    </label>
    <label>Frequency Range: <span id="leftPitchRangeVal">600</span> Hz
      <input type="range" id="leftPitchRange" min="200" max="1200" value="600">
    </label>
    <label>Carrier Amplitude: <span id="leftMaxGainVal">0.4</span>
      <input type="range" id="leftMaxGain" min="0" max="1" step="0.01" value="0.4">
    </label>
    <label>Attack Time: <span id="carrierAttackVal">0.05</span>s
      <input type="range" id="carrierAttack" min="0.01" max="0.5" step="0.01" value="0.05">
    </label>
  </div>

  <!-- Right Hand Controls Panel -->
  <div class="panel-header" id="right-header">
    <span>üëâ Right Hand - Modulator Oscillator</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="right-panel">
    <label>Modulator Waveform:
      <select id="rightWaveform">
        <option value="sine" selected>Sine Wave</option>
        <option value="triangle">Triangle Wave</option>
        <option value="sawtooth">Sawtooth Wave</option>
        <option value="square">Square Wave</option>
      </select>
    </label>
    <label>Modulator Amplitude: <span id="rightMaxGainVal">0.3</span>
      <input type="range" id="rightMaxGain" min="0" max="1" step="0.01" value="0.3">
    </label>
    <label>Frequency Range: <span id="rightPitchRangeVal">8.0</span> ratio
      <input type="range" id="rightPitchRange" min="0.5" max="16" step="0.1" value="8.0">
    </label>
    <label>Modulation Depth: <span id="rightModDepthVal">100</span> Hz
      <input type="range" id="rightModDepth" min="0" max="500" step="10" value="100">
    </label>
    <label>Release Time: <span id="modulatorReleaseVal">0.3</span>s
      <input type="range" id="modulatorRelease" min="0.1" max="2.0" step="0.1" value="0.3">
    </label>
  </div>

  <!-- Rhythm Engine Panel -->
  <div class="panel-header" id="rhythm-header">
    <span>ü•Å Rhythm Engine</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="rhythm-panel">
    <div class="visual-controls" style="border-color: #ff4;">
      <strong>ü•Å Beat Control:</strong><br>
      <label>Pattern:
        <select id="rhythmPattern">
          <option value="off" selected>Off (No Rhythm)</option>
          <option value="4/4">4/4 Kick Pattern</option>
          <option value="kick-snare">Kick & Snare</option>
          <option value="triplets">Triplet Feel</option>
          <option value="syncopated">Syncopated</option>
          <option value="dense">Dense Pattern</option>
        </select>
      </label>
      <label>Tempo: <span id="tempoVal">120</span> BPM
        <input type="range" id="tempo" min="60" max="180" value="120">
      </label>
      <label>Rhythm Volume: <span id="rhythmVolumeVal">0.6</span>
        <input type="range" id="rhythmVolume" min="0" max="1" step="0.05" value="0.6">
      </label>
      <div id="beat-indicator" style="width: 20px; height: 20px; border-radius: 50%; background: #333; margin: 10px 0; transition: all 0.1s;"></div>
      <div id="rhythm-status" style="font-size: 11px; color: #ff4;">Rhythm: Off</div>
    </div>
  </div>

  <!-- Global Settings Panel -->
  <div class="panel-header" id="global-header">
    <span>‚öôÔ∏è Global Settings</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="global-panel">
    <label>Master Volume: <span id="masterVolumeVal">0.7</span>
      <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.7">
    </label>
    <label>Smoothing: <span id="smoothingVal">0.15</span>
      <input type="range" id="smoothing" min="0.01" max="0.5" step="0.01" value="0.15">
    </label>
  </div>
</div>

<video id="video" autoplay playsinline style="display:none"></video>
<canvas id="video-canvas"></canvas>
<canvas id="overlay-canvas"></canvas>

<!-- ML5.js library -->
<script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>

<script>
(async () => {
  // Debug logging - Updated for FM synthesizer v2
  function debugLog(message, data = null) {
    console.log(`[FM-Synth-v2] ${message}`, data || '');
  }

  debugLog('Initializing Complete Gesture Theremin v5 - Onboarding & Scales');

  // DOM elements
  const video = document.getElementById('video');
  const vcanvas = document.getElementById('video-canvas'), vctx = vcanvas.getContext('2d');
  const ocanvas = document.getElementById('overlay-canvas'), octx = ocanvas.getContext('2d');

  const modelStatus = document.getElementById('model-status');
  const handDetectionStatus = document.getElementById('hand-detection-status');
  const gestureFeedback = document.getElementById('gesture-feedback');
  const soundLayers = document.getElementById('sound-layers');

  // Control elements - Updated for FM synthesis
  const ctrl = {};
  ['leftWaveform', 'leftBasePitch', 'leftPitchRange', 'leftMaxGain', 'carrierAttack',
   'rightWaveform', 'rightMaxGain', 'rightPitchRange', 'rightModDepth', 'modulatorRelease', 
   'carrierRatio', 'modulatorRatio', 'modulationIndex', 'feedback',
   'masterVolume', 'smoothing', 'effectIntensity', 'handGlow', 'maxDistance', 'minDistance',
   'scaleType', 'rootNote', 'rhythmPattern', 'tempo', 'rhythmVolume'].forEach(id => {
    ctrl[id] = document.getElementById(id);
  });
  
  // Debug: Log successful control initialization per rules
  debugLog('‚úÖ FM synthesizer controls initialized with new parameters');

  // Additional DOM elements for calibration
  const distanceDebug = document.getElementById('distance-debug');
  const scaleInfo = document.getElementById('scale-info');

  // [FM-Synth-v2] Rhythm system DOM elements
  const beatIndicator = document.getElementById('beat-indicator');
  const rhythmStatus = document.getElementById('rhythm-status');

  // Main collapse button
  const mainCollapseBtn = document.getElementById('main-collapse-btn');

  // Face detection variables (for mask effect, not mouth tracking)
  let facemesh = null;
  let faceDetections = [];

  // Mobile detection and main collapse functionality
  function isMobile() {
    return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           window.innerWidth <= 768;
  }

  // Initialize collapse state based on device
  let isMainCollapsed = isMobile();

  // Main menu collapse functionality
  function toggleMainCollapse() {
    isMainCollapsed = !isMainCollapsed;
    const controls = document.getElementById('controls');
    
    if (isMainCollapsed) {
      controls.classList.add('collapsed');
      mainCollapseBtn.textContent = '‚ñ∂';
      debugLog('üéõÔ∏è Controls panel collapsed');
    } else {
      controls.classList.remove('collapsed');
      mainCollapseBtn.textContent = '‚óÄ';
      debugLog('üéõÔ∏è Controls panel expanded');
    }
  }

  // COLLAPSIBLE PANEL SYSTEM - Updated for FM synthesis panels
  function initializePanels() {
    const headers = ['system', 'fm', 'gesture', 'scale', 'visual', 'left', 'right', 'rhythm', 'global'];
    
    headers.forEach(name => {
      const header = document.getElementById(`${name}-header`);
      const panel = document.getElementById(`${name}-panel`);
      const arrow = header.querySelector('.panel-arrow');
      
      if (!header || !panel || !arrow) {
        debugLog(`‚ö†Ô∏è Panel ${name} not found - skipping`);
        return; // Skip if elements don't exist
      }
      
      // Start with some panels collapsed to save space
      // Keep FM panel expanded by default for easy access
      if (['left', 'right', 'global', 'visual'].includes(name)) {
        panel.classList.add('collapsed');
        header.classList.add('collapsed');
        arrow.classList.add('collapsed');
      }
      
      header.onclick = () => {
        const isCollapsed = panel.classList.contains('collapsed');
        
        if (isCollapsed) {
          panel.classList.remove('collapsed');
          header.classList.remove('collapsed');
          arrow.classList.remove('collapsed');
        } else {
          panel.classList.add('collapsed');
          header.classList.add('collapsed');
          arrow.classList.add('collapsed');
        }
        
        debugLog(`üì± Panel ${name} ${isCollapsed ? 'expanded' : 'collapsed'}`);
      };
    });
    
    debugLog('‚úÖ FM synthesizer panels initialized with debug logging per rules');
  }

  // MUSICAL SCALE SYSTEM
  const scaleDefinitions = {
    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], // All semitones
    major: [0, 2, 4, 5, 7, 9, 11], // Major scale intervals
    minor: [0, 2, 3, 5, 7, 8, 10], // Natural minor scale
    pentatonic: [0, 2, 4, 7, 9], // Major pentatonic
    colundi: [0, 1, 3, 5, 6, 8, 10] // Locrian mode (colundi approximation)
  };

  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  
  function noteToFrequency(noteIndex) {
    // A4 = 440Hz at index 57 (A4 in MIDI)
    const A4_INDEX = 57;
    const A4_FREQ = 440;
    return A4_FREQ * Math.pow(2, (noteIndex - A4_INDEX) / 12);
  }

  function quantizeToScale(frequency) {
    const scaleType = ctrl.scaleType.value;
    const rootNote = ctrl.rootNote.value;
    
    if (scaleType === 'chromatic') {
      // No quantization for chromatic
      return frequency;
    }
    
    // Find the closest MIDI note
    const midiNote = Math.round(12 * Math.log2(frequency / 440) + 69);
    
    // Get root note index (C = 0, C# = 1, etc.)
    const rootIndex = noteNames.indexOf(rootNote);
    
    // Get scale intervals
    const scaleIntervals = scaleDefinitions[scaleType];
    
    // Find the closest note in the scale
    let closestNote = midiNote;
    let minDistance = Infinity;
    
    // Check all octaves around the target note
    for (let octave = -2; octave <= 2; octave++) {
      scaleIntervals.forEach(interval => {
        const scaleNote = rootIndex + interval + (octave * 12) + Math.floor((midiNote - rootIndex) / 12) * 12;
        const distance = Math.abs(midiNote - scaleNote);
        
        if (distance < minDistance) {
          minDistance = distance;
          closestNote = scaleNote;
        }
      });
    }
    
    return noteToFrequency(closestNote);
  }

  function updateScaleInfo() {
    const scaleType = ctrl.scaleType.value;
    const rootNote = ctrl.rootNote.value;
    scaleInfo.textContent = `Current scale: ${rootNote} ${scaleType.charAt(0).toUpperCase() + scaleType.slice(1)}`;
  }

  // Scale control event listeners
  ctrl.scaleType.onchange = updateScaleInfo;
  ctrl.rootNote.onchange = updateScaleInfo;

  // Canvas sizing
  let width = window.innerWidth, height = window.innerHeight;
  [vcanvas, ocanvas].forEach(c => { c.width = width; c.height = height; });

  // Set dynamic distance values based on screen height
  function updateDistanceCalibration() {
    const maxDistance = height * 0.7;     // Close hand = 70% of screen height (100% vol)
    const minDistance = height * 0.1;     // Far hand = 10% of screen height (0% vol)
    
    // Update control values
    ctrl.maxDistance.value = maxDistance;
    ctrl.minDistance.value = minDistance;
    
    // Update the displayed values
    document.getElementById('maxDistanceVal').textContent = Math.round(maxDistance);
    document.getElementById('minDistanceVal').textContent = Math.round(minDistance);
    
    // Update slider ranges to accommodate the new values
    ctrl.maxDistance.max = Math.max(maxDistance * 1.5, 800);
    ctrl.minDistance.max = Math.max(minDistance * 3, 200);
    
    debugLog(`üìè Dynamic distance calibration: Close=${maxDistance}px, Far=${minDistance}px (based on screen height: ${height}px)`);
  }
  
  updateDistanceCalibration();
  
  // Bind control values to display spans
  function bind(id, spanId) {
    const inp = document.getElementById(id), span = document.getElementById(spanId);
    if (!inp || !span) return;
    span.innerText = inp.value;
    inp.oninput = () => span.innerText = inp.value;
  }

  // Bind all controls
  ['leftBasePitch', 'leftPitchRange', 'leftLfoDepth', 'leftMaxGain',
   'rightMaxGain', 'rightPitchRange', 'rightMinPitch', 'rightReverbWet',
   'masterVolume', 'smoothing', 'effectIntensity', 'handGlow', 'maxDistance', 'minDistance',
   'tempo', 'rhythmVolume'].forEach(id => {
    bind(id, id + 'Val');
  });

  // FM SYNTHESIS AUDIO SYSTEM - Core implementation per rules
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let masterGainNode;
  let activeSounds = new Map();
  let soundIdCounter = 0;

  // Smooth value transitions for FM parameters
  class SmoothedValue {
    constructor(initialValue = 0, smoothing = 0.15) {
      this.value = initialValue;
      this.target = initialValue;
      this.smoothing = smoothing;
    }
    
    update(newTarget, customSmoothing = null) {
      this.target = newTarget;
      const alpha = customSmoothing !== null ? customSmoothing : this.smoothing;
      this.value = alpha * this.target + (1 - alpha) * this.value;
      return this.value;
    }
  }

  // FM Synthesis Sound Layer - Implements true frequency modulation
  class FMSoundLayer {
    constructor(id, hand) {
      this.id = id;
      this.hand = hand; // Store hand data for gesture mapping
      this.active = false;
      this.sustained = false;
      
      // Visual properties for frozen representation
      this.frozenPosition = null;
      this.frozenColor = null;
      this.frozenParams = null;
      
             // FM synthesis parameters with smooth interpolation - Added vibrato and operator support
       this.params = {
         carrierFreq: new SmoothedValue(220, 0.2),
         modulatorRatio: new SmoothedValue(1.0, 0.15),
         modulationIndex: new SmoothedValue(2.0, 0.15),
         masterVolume: new SmoothedValue(0, 0.2),
         feedback: new SmoothedValue(0.15, 0.15), // Start with some feedback for immediate sound
         vibratoDepth: new SmoothedValue(0, 0.15),
         operatorCount: new SmoothedValue(1, 0.3)
       };
      
      debugLog(`üéõÔ∏è Creating FM sound layer #${this.id} with carrier + modulator`);
      this.createFMAudioNodes();
    }
    
    createFMAudioNodes() {
      try {
        // Create carrier oscillator (main sound)
        this.carrier = audioCtx.createOscillator();
        this.carrier.type = ctrl.leftWaveform ? ctrl.leftWaveform.value : 'sine';
        
        // Create modulator oscillator (FM source)
        this.modulator = audioCtx.createOscillator();
        this.modulator.type = ctrl.rightWaveform ? ctrl.rightWaveform.value : 'sine';
        
        // Create modulation depth control (modulation index)
        this.modulationGain = audioCtx.createGain();
        this.modulationGain.gain.value = 0;
        
        // Create feedback delay for more complex FM timbres
        this.feedbackDelay = audioCtx.createDelay(0.01);
        this.feedbackDelay.delayTime.value = 0.001; // Very short delay
        this.feedbackGain = audioCtx.createGain();
        this.feedbackGain.gain.value = 0;
        
        // Create envelope controls
        this.masterGain = audioCtx.createGain();
        this.masterGain.gain.value = 0;
        
                 // Create vibrato LFO for musical expression
         this.vibratoLFO = audioCtx.createOscillator();
         this.vibratoLFO.type = 'sine';
         this.vibratoLFO.frequency.value = 5; // 5Hz vibrato
         this.vibratoGain = audioCtx.createGain();
         this.vibratoGain.gain.value = 0; // Start with no vibrato
         
         // Create filter for timbral shaping
         this.filter = audioCtx.createBiquadFilter();
         this.filter.type = 'lowpass';
         this.filter.frequency.value = 2000;
         this.filter.Q.value = 1;
        
                 // Connect FM synthesis chain:
         // Modulator -> Modulation Gain -> Carrier frequency (FM!)
         this.modulator.connect(this.modulationGain);
         this.modulationGain.connect(this.carrier.frequency);
         
         // Connect vibrato LFO to carrier frequency for musical expression
         this.vibratoLFO.connect(this.vibratoGain);
         this.vibratoGain.connect(this.carrier.frequency);
        
        // Add feedback loop for richer harmonics
        this.carrier.connect(this.feedbackDelay);
        this.feedbackDelay.connect(this.feedbackGain);
        this.feedbackGain.connect(this.carrier.frequency);
        
        // Main signal path: Carrier -> Filter -> Master Gain -> Output
        this.carrier.connect(this.filter);
        this.filter.connect(this.masterGain);
        this.masterGain.connect(masterGainNode);
        
                 // Start oscillators and vibrato LFO
         this.carrier.start();
         this.modulator.start();
         this.vibratoLFO.start();
        
        debugLog(`‚úÖ FM synthesis chain created for layer #${this.id}: Modulator->Carrier with feedback`);
        
      } catch (error) {
        debugLog(`‚ùå Error creating FM audio nodes for layer #${this.id}:`, error);
      }
    }
    
         // Update FM parameters based on hand gestures - New finger count mapping
     updateFromGestures(leftHand, rightHand) {
       if (!this.carrier || !this.modulator) return;
       
       try {
         // Left hand controls carrier frequency, volume, and harmonic content - SWAPPED X/Y
         if (leftHand) {
           // Map Y position to carrier frequency within musical scale (VERTICAL = FREQUENCY)
           const baseFreq = parseFloat(ctrl.leftBasePitch?.value || 220);
           const freqRange = parseFloat(ctrl.leftPitchRange?.value || 600);
           const rawFreq = baseFreq + ((1 - leftHand.y / height) * freqRange); // Inverted Y for musical feel
           
           // Quantize to musical scale
           const carrierFreq = quantizeToScale(rawFreq);
           this.params.carrierFreq.update(carrierFreq);
           
           // Map X position to modulation index (FM depth) - HORIZONTAL = MOD INDEX
           const modIndex = (leftHand.x / width) * 10; // 0-10 range
           this.params.modulationIndex.update(modIndex);
           
           // Distance controls master volume
           const volume = leftHand.z * parseFloat(ctrl.leftMaxGain?.value || 0.4);
           this.params.masterVolume.update(volume);
           
           // NEW: Finger count controls vibrato depth for musical expression
           const fingerCount = leftHand.fingerCount || 1;
           const vibratoDepth = (fingerCount - 1) * 5; // 0-20 Hz vibrato range
           this.params.vibratoDepth.update(vibratoDepth);
           debugLog(`üñêÔ∏è Left hand: ${fingerCount} fingers = ${vibratoDepth}Hz vibrato depth`);
         }
         
         // Right hand controls modulator ratio, feedback, and filter resonance - SWAPPED X/Y
         if (rightHand) {
           // Map Y position to modulator frequency ratio (VERTICAL = RATIO)
           const ratioRange = parseFloat(ctrl.rightPitchRange?.value || 8);
           const modulatorRatio = 0.1 + ((1 - rightHand.y / height) * ratioRange); // Inverted Y
           this.params.modulatorRatio.update(modulatorRatio);
           
           // Map X position to feedback amount (HORIZONTAL = FEEDBACK)
           const feedbackAmount = 0.1 + (rightHand.x / width) * 0.2; // Start at 0.1, range 0.1-0.3
           this.params.feedback.update(feedbackAmount);
           
           // NEW: Finger count controls FM operator complexity
           const fingerCount = rightHand.fingerCount || 1;
           const operatorCount = fingerCount; // 1-5 operators
           this.params.operatorCount.update(operatorCount);
           debugLog(`üñêÔ∏è Right hand: ${fingerCount} fingers = ${operatorCount} FM operators`);
         }
         
         // Apply all parameter updates to audio nodes
         this.applyFMParameters();
         
       } catch (error) {
         debugLog(`‚ùå Error updating FM parameters for layer #${this.id}:`, error);
       }
     }
    
         // Apply calculated FM parameters to Web Audio nodes - Updated for finger count control
     applyFMParameters() {
       const now = audioCtx.currentTime;
       
       // Set carrier frequency
       this.carrier.frequency.setTargetAtTime(
         this.params.carrierFreq.value, now, 0.02
       );
       
       // Set modulator frequency (carrier frequency * ratio)
       const modulatorFreq = this.params.carrierFreq.value * this.params.modulatorRatio.value;
       this.modulator.frequency.setTargetAtTime(modulatorFreq, now, 0.02);
       
       // Set modulation depth (frequency range modulated by modulator)
       const modDepth = this.params.carrierFreq.value * this.params.modulationIndex.value;
       this.modulationGain.gain.setTargetAtTime(modDepth, now, 0.02);
       
       // Set feedback amount for harmonic complexity
       this.feedbackGain.gain.setTargetAtTime(this.params.feedback.value, now, 0.02);
       
       // Set master volume
       this.masterGain.gain.setTargetAtTime(this.params.masterVolume.value, now, 0.02);
       
       // NEW: Apply vibrato and operator count controls
       // Left hand finger count affects vibrato depth
       this.vibratoGain.gain.setTargetAtTime(this.params.vibratoDepth.value, now, 0.05);
       
       // Filter cutoff based on modulation index and operator count
       const baseFilterFreq = 500 + (this.params.modulationIndex.value / 10) * 3000;
       const operatorMultiplier = 1 + (this.params.operatorCount.value - 1) * 0.3; // More operators = brighter
       this.filter.frequency.setTargetAtTime(baseFilterFreq * operatorMultiplier, now, 0.05);
       
       // Operator count affects filter resonance for complexity
       const operatorQ = 1 + (this.params.operatorCount.value - 1) * 2; // 1-9 Q range
       this.filter.Q.setTargetAtTime(operatorQ, now, 0.05);
     }
    
    // Freeze the visual and audio state when sustained
    freezeState(hand) {
      this.frozenPosition = { x: hand.x, y: hand.y };
      this.frozenParams = {
        carrierFreq: this.params.carrierFreq.value,
        modulatorRatio: this.params.modulatorRatio.value,
        modulationIndex: this.params.modulationIndex.value
      };
      this.frozenColor = `hsl(${(this.frozenParams.carrierFreq / 1000) * 360}, 80%, 60%)`;
      debugLog(`üßä Frozen FM layer #${this.id} at ${this.frozenParams.carrierFreq.toFixed(1)}Hz`);
    }
    
    // Clean up audio nodes when destroying layer
    destroy() {
      debugLog(`üóëÔ∏è Destroying FM layer #${this.id}`);
      
      try {
        // Fade out quickly
        this.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02);
        
        setTimeout(() => {
          try {
            this.carrier.stop();
            this.modulator.stop();
            this.masterGain.disconnect();
          } catch (e) {
            debugLog(`‚ö†Ô∏è Error stopping oscillators for layer #${this.id}:`, e);
          }
        }, 50);
      } catch (error) {
        debugLog(`‚ùå Error destroying FM layer #${this.id}:`, error);
      }
    }
  }

  // Initialize audio system - Auto-start when hands detected
  let audioStarted = false;

  // [FM-Synth-v2] Rhythm system variables
  let rhythmPatterns = {
    'off': [],
    '4/4': [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
    'kick-snare': [1, 0, 0, 0, 0.5, 0, 0, 0, 1, 0, 0, 0, 0.5, 0, 0, 0],
    'triplets': [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
    'syncopated': [1, 0, 0.3, 0, 0, 0.7, 0, 0, 1, 0, 0, 0.3, 0, 0.7, 0, 0],
    'dense': [1, 0.3, 0.6, 0.3, 0.8, 0.3, 0.6, 0.3, 1, 0.3, 0.6, 0.3, 0.8, 0.3, 0.6, 0.3]
  };
  let currentPattern = 'off';
  let currentStep = 0;
  let tempo = 120; // BPM
  let stepInterval = null;
  let isRhythmPlaying = false;
  let rhythmGain = null;
  let gateGain = null;
  let lastHandsDetectedTime = 0;
  let autoStartThreshold = 2000; // 2 seconds of hand detection before auto-starting audio
  
  function initializeAudio() {
    debugLog('üéµ Audio system ready - will auto-start when hands detected');
    handDetectionStatus.textContent = 'üéµ Show hands to start FM synthesizer!';
  }
  
  function startAudioIfNeeded() {
    if (audioStarted) return;
    
    try {
      audioCtx.resume().then(() => {
        // Create master gain node
        masterGainNode = audioCtx.createGain();
        masterGainNode.connect(audioCtx.destination);
        masterGainNode.gain.value = parseFloat(ctrl.masterVolume?.value || 0.7);
        
        // Initialize rhythm system
        initializeRhythmSystem();
        
        audioStarted = true;
        debugLog('‚úÖ FM synthesis audio auto-started on hand detection');
        handDetectionStatus.textContent = 'FM synthesizer active - move hands to play!';
      }).catch(error => {
        debugLog('‚ùå Audio auto-start failed, click anywhere to start:', error);
        handDetectionStatus.textContent = 'Click anywhere to start audio, then show hands';
        
        // Fallback to click-to-start
        document.addEventListener('click', function startAudioOnClick() {
          audioCtx.resume().then(() => {
            masterGainNode = audioCtx.createGain();
            masterGainNode.connect(audioCtx.destination);
            masterGainNode.gain.value = parseFloat(ctrl.masterVolume?.value || 0.7);
            
            // Initialize rhythm system
            initializeRhythmSystem();
            
            audioStarted = true;
            debugLog('‚úÖ FM audio started after user click');
            handDetectionStatus.textContent = 'Audio started - show hands to play!';
          });
          document.removeEventListener('click', startAudioOnClick);
        }, { once: true });
      });
    } catch (error) {
      debugLog('‚ùå Audio system error:', error);
      handDetectionStatus.textContent = 'Audio not supported in this browser';
    }
  }

  // [FM-Synth-v2] Rhythm System Implementation
  function initializeRhythmSystem() {
    if (!audioCtx || !masterGainNode) return;
    
    // Create rhythm gain node for volume control
    rhythmGain = audioCtx.createGain();
    rhythmGain.gain.value = 0.6; // Default rhythm volume
    rhythmGain.connect(masterGainNode);
    
    // Create gate effect gain for rhythmic gating
    gateGain = audioCtx.createGain();
    gateGain.gain.value = 1.0; // Start with full gate
    
    debugLog('‚úÖ Rhythm system initialized');
  }

  function startRhythm() {
    if (isRhythmPlaying || currentPattern === 'off') return;
    
    isRhythmPlaying = true;
    currentStep = 0;
    
    const stepDuration = (60 / tempo / 4) * 1000; // 16th note timing
    
    stepInterval = setInterval(() => {
      const pattern = rhythmPatterns[currentPattern];
      if (!pattern || pattern.length === 0) return;
      
      const beatStrength = pattern[currentStep % pattern.length];
      
      if (beatStrength > 0) {
        // Visual beat indicator
        const beatIndicator = document.getElementById('beat-indicator');
        if (beatIndicator) {
          beatIndicator.style.background = '#ff4';
          beatIndicator.style.transform = 'scale(1.5)';
          setTimeout(() => {
            beatIndicator.style.background = '#333';
            beatIndicator.style.transform = 'scale(1)';
          }, 100);
        }
        
        // Trigger rhythmic gate effect on FM synthesis
        triggerRhythmicGate(beatStrength);
        
        debugLog(`ü•Å Beat ${currentStep + 1} - strength: ${beatStrength}`);
      }
      
      currentStep = (currentStep + 1) % pattern.length;
    }, stepDuration);
    
    const rhythmStatus = document.getElementById('rhythm-status');
    if (rhythmStatus) {
      rhythmStatus.textContent = `Rhythm: ${currentPattern} at ${tempo} BPM`;
    }
    debugLog(`ü•Å Started rhythm: ${currentPattern} at ${tempo} BPM`);
  }

  function stopRhythm() {
    if (!isRhythmPlaying) return;
    
    isRhythmPlaying = false;
    if (stepInterval) {
      clearInterval(stepInterval);
      stepInterval = null;
    }
    
    const rhythmStatus = document.getElementById('rhythm-status');
    if (rhythmStatus) {
      rhythmStatus.textContent = 'Rhythm: Off';
    }
    debugLog('ü•Å Rhythm stopped');
  }

  function triggerRhythmicGate(strength) {
    if (!gateGain || !currentFMLayer) return;
    
    const now = audioCtx.currentTime;
    const rhythmVolume = parseFloat(ctrl.rhythmVolume?.value || 0.6);
    
    // Create rhythmic amplitude modulation
    const gateAmount = 0.3 + (strength * 0.7); // 0.3 to 1.0 range
    const effectiveGain = gateAmount * rhythmVolume;
    
    // Apply quick envelope for punchy rhythm
    if (currentFMLayer && currentFMLayer.masterGain) {
      const baseGain = currentFMLayer.params.masterVolume.value;
      const rhythmicGain = baseGain * (1 + effectiveGain);
      
      // Quick attack and decay for rhythmic punch
      currentFMLayer.masterGain.gain.cancelScheduledValues(now);
      currentFMLayer.masterGain.gain.setValueAtTime(baseGain, now);
      currentFMLayer.masterGain.gain.linearRampToValueAtTime(rhythmicGain, now + 0.01);
      currentFMLayer.masterGain.gain.exponentialRampToValueAtTime(baseGain + 0.01, now + 0.15);
    }
  }

  function updateRhythmSettings() {
    tempo = parseInt(ctrl.tempo?.value || 120);
    currentPattern = ctrl.rhythmPattern?.value || 'off';
    
    // Update rhythm gain
    if (rhythmGain) {
      const volume = parseFloat(ctrl.rhythmVolume?.value || 0.6);
      rhythmGain.gain.setTargetAtTime(volume, audioCtx.currentTime, 0.1);
    }
    
    // Restart rhythm if playing
    if (isRhythmPlaying) {
      stopRhythm();
      if (currentPattern !== 'off') {
        setTimeout(() => startRhythm(), 100);
      }
    } else if (currentPattern !== 'off') {
      startRhythm();
    }
    
    debugLog(`ü•Å Rhythm updated: ${currentPattern} at ${tempo} BPM`);
  }

  // Gesture state tracking for FM synthesis
  let gestureState = { active: false, leftHand: null, rightHand: null };
  let currentFMLayer = null;

  // Handle gesture-based FM synthesis control
  function handleFMGestures(hands) {
    const leftHand = hands.left;
    const rightHand = hands.right;
    
    // Auto-start audio when ANY hand is detected
    if ((leftHand || rightHand) && !audioStarted) {
      startAudioIfNeeded();
    }
    
    if (!masterGainNode) return;
    
         // Update gesture feedback display - Updated for new X/Y mapping
     let statusText = '';
     if (leftHand) {
       const carrierFreq = quantizeToScale(
         parseFloat(ctrl.leftBasePitch?.value || 220) + 
         ((1 - leftHand.y / height) * parseFloat(ctrl.leftPitchRange?.value || 600))
       );
       const modIndex = ((leftHand.x / width) * 10).toFixed(1);
       statusText += `üéõÔ∏è LEFT: Carrier ${carrierFreq.toFixed(1)}Hz, Mod Index ${modIndex} | `;
     }
    
         if (rightHand) {
       const modRatio = (0.1 + ((1 - rightHand.y / height) * parseFloat(ctrl.rightPitchRange?.value || 8))).toFixed(2);
       const feedback = (0.1 + (rightHand.x / width) * 0.2).toFixed(2);
       statusText += `üëâ RIGHT: Mod Ratio ${modRatio}, Feedback ${feedback}`;
     }
    
         // Create or update FM layer when hands are detected
     if ((leftHand || rightHand) && !currentFMLayer) {
       // Auto-start audio when hands first detected
       startAudioIfNeeded();
       
       const newId = ++soundIdCounter;
       currentFMLayer = new FMSoundLayer(newId, { left: leftHand, right: rightHand });
       currentFMLayer.active = true;
       activeSounds.set(newId, currentFMLayer);
       debugLog(`üéµ New FM layer #${newId} created with both hands`);
     }
    
    // Update existing layer with current hand positions
    if (currentFMLayer && currentFMLayer.active) {
      currentFMLayer.updateFromGestures(leftHand, rightHand);
    }
    
    // Destroy layer when both hands are removed
    if (!leftHand && !rightHand && currentFMLayer) {
      currentFMLayer.destroy();
      activeSounds.delete(currentFMLayer.id);
      currentFMLayer = null;
      debugLog(`üóëÔ∏è FM layer destroyed - no hands detected`);
    }
    
    // Update UI displays
    gestureFeedback.textContent = statusText || 'Show hands to control FM synthesis...';
    soundLayers.innerHTML = currentFMLayer ? 
      `Active FM Layer #${currentFMLayer.id}` : 
      'No active layers';
  }

  // VIDEO AND HAND DETECTION SYSTEM - Restored for FM synthesizer
  let webcamRunning = false;
  let frameCount = 0;
  let handpose = null;
  let predictions = [];

  // Initialize camera and ML5 hand detection
  async function initializeCamera() {
    debugLog('üé• Requesting camera access for FM synthesizer...');
    
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { 
          width: 1280, 
          height: 720,
          facingMode: "user"
        } 
      });
      video.srcObject = stream; 
      await video.play();
      webcamRunning = true;
      debugLog('‚úÖ Camera access granted and video stream started');
      
             // Load ML5 hand pose model
       handpose = ml5.handPose({
         flipHorizontal: true,
         maxNumHands: 2,
         runtime: 'mediapipe',
         modelType: 'full'
       }, () => {
         debugLog('‚úÖ ML5.js HandPose model loaded successfully');
         // Turn status indicator GREEN when everything is working
         modelStatus.classList.add('active');
         handDetectionStatus.textContent = 'FM synthesizer ready - show hands to play!';
         detectHands();
       });
      
    } catch (error) {
      debugLog('‚ùå Error accessing camera:', error);
      handDetectionStatus.textContent = 'Camera access required for hand detection';
    }
  }

  // Hand detection loop
  async function detectHands() {
    if (handpose && webcamRunning) {
      try {
        predictions = await handpose.detect(video);
      } catch (error) {
        debugLog('Error during hand detection:', error);
        predictions = [];
      }
    }
    setTimeout(detectHands, 100);
  }

  // Process hand data for FM synthesis
  function processHands() {
    if (!predictions || predictions.length === 0) {
      return { left: null, right: null, headOutOfFrame: false };
    }

    const hands = predictions.map(pred => {
      if (!pred.keypoints || pred.keypoints.length === 0) return null;
      
      let sx = 0, sy = 0;
      pred.keypoints.forEach(kp => { sx += kp.x; sy += kp.y; });
      
      // Scale coordinates from video resolution to canvas size
      const rawX = sx / pred.keypoints.length;
      const rawY = sy / pred.keypoints.length;
      const scaledX = (rawX / 1280) * width;
      const scaledY = (rawY / 720) * height;
      
      // Simple finger count
      const fingerCount = countExtendedFingers(pred.keypoints);
      
      // Simple depth calculation based on hand size
      const depth = calculateHandDepth(pred.keypoints);
      
      return { 
        x: scaledX, 
        y: scaledY,
        z: depth,
        fingerCount: fingerCount,
        handedness: pred.handedness || 'Unknown'
      };
    }).filter(hand => hand !== null);

    // Assign left/right hands
    let left = null, right = null;
    if (hands.length === 1) {
      // Single hand - assign based on position or handedness
      const hand = hands[0];
      if (hand.handedness === 'Left') {
        left = hand;
      } else if (hand.handedness === 'Right') {
        right = hand;
      } else {
        // Fallback to position
        if (hand.x < width / 2) {
          right = hand;
        } else {
          left = hand;
        }
      }
    } else if (hands.length >= 2) {
      // Multiple hands - try handedness first
      hands.forEach(hand => {
        if (hand.handedness === 'Left') {
          left = hand;
        } else if (hand.handedness === 'Right') {
          right = hand;
        }
      });
      
      // Fallback to position if handedness failed
      if (!left && !right) {
        hands.sort((a, b) => a.x - b.x);
        right = hands[0];
        left = hands[hands.length - 1];
      }
    }

    return { left, right, headOutOfFrame: false };
  }

  // Simple finger counting
  function countExtendedFingers(keypoints) {
    if (!keypoints || keypoints.length < 21) return 1;
    
    const fingerTips = [8, 12, 16, 20];    // Index, Middle, Ring, Pinky tips
    const fingerMCPs = [5, 9, 13, 17];     // Index, Middle, Ring, Pinky MCPs
    const thumbTip = 4;
    const thumbIP = 3;
    
    let extendedCount = 0;
    
    // Check thumb
    const thumbDiff = keypoints[thumbTip].x - keypoints[thumbIP].x;
    if (thumbDiff > 15) extendedCount++;
    
    // Check other fingers
    for (let i = 0; i < 4; i++) {
      const tipY = keypoints[fingerTips[i]].y;
      const mcpY = keypoints[fingerMCPs[i]].y;
      if (mcpY - tipY > 25) extendedCount++;
    }
    
    return Math.max(1, Math.min(extendedCount, 5));
  }

  // Simple hand depth calculation
  function calculateHandDepth(keypoints) {
    if (!keypoints || keypoints.length < 21) return 0.5;
    
    const wrist = keypoints[0];
    const middleTip = keypoints[12];
    
    if (!wrist || !middleTip) return 0.5;
    
    const distance = Math.sqrt(
      Math.pow(middleTip.x - wrist.x, 2) + 
      Math.pow(middleTip.y - wrist.y, 2)
    );
    
    // Map distance to volume (40-120 pixel range)
    const minDistance = 40;
    const maxDistance = 120;
    return Math.max(0, Math.min(1, (distance - minDistance) / (maxDistance - minDistance)));
  }
  
  function render() {
    frameCount++;
    
    // Draw video feed
    if (webcamRunning) {
      vctx.save(); 
      vctx.scale(-1, 1); 
      vctx.drawImage(video, -width, 0, width, height); 
      vctx.restore();
    }

    // Clear overlay canvas
    octx.clearRect(0, 0, width, height);
    
    // Process hand detection and update FM synthesis
    const hands = processHands();
    handleFMGestures(hands);
    
    // Simple hand visualization
    ['left', 'right'].forEach(handType => {
      const hand = hands[handType];
      if (!hand) return;
      
      // Draw hand position
      octx.fillStyle = handType === 'left' ? '#ff4444' : '#4444ff';
      octx.beginPath();
      octx.arc(hand.x, hand.y, 20, 0, 2 * Math.PI);
      octx.fill();
      
      // Show finger count
      octx.fillStyle = 'white';
      octx.font = 'bold 16px Arial';
      octx.fillText(hand.fingerCount.toString(), hand.x - 5, hand.y + 5);
    });
    
    requestAnimationFrame(render);
  }

  // Initialize main collapse functionality
  function initializeMainCollapse() {
    if (isMainCollapsed) {
      const controls = document.getElementById('controls');
      controls.classList.add('collapsed');
      mainCollapseBtn.textContent = '‚ñ∂';
      debugLog('üéõÔ∏è Controls panel initialized as collapsed (mobile detected)');
    }
  }

  // Main collapse button event listener
  mainCollapseBtn.onclick = toggleMainCollapse;

  // [FM-Synth-v2] Rhythm control event listeners
  if (ctrl.rhythmPattern) {
    ctrl.rhythmPattern.onchange = updateRhythmSettings;
  }
  if (ctrl.tempo) {
    ctrl.tempo.oninput = updateRhythmSettings;
  }
  if (ctrl.rhythmVolume) {
    ctrl.rhythmVolume.oninput = updateRhythmSettings;
  }

  // Initialize system components
  initializePanels();
  initializeMainCollapse(); // Initialize main collapse for mobile
  initializeAudio(); // Auto-start FM audio system
  initializeCamera(); // Start camera and hand detection
  debugLog('üéõÔ∏è Starting FM synthesizer v2 with rhythm engine');
  render();

})().catch(error => {
  console.error('‚ùå Fatal initialization error:', error);
  alert('Failed to initialize application: ' + error.message);
});
</script>
</body>
</html>