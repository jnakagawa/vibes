<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>FM Synth v3 - Philip Glass Composition Engine</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:black; color:white; }
  #controls {
    position:absolute; top:10px; left:10px;
    background:rgba(0,0,0,0.8); padding:15px; border-radius:10px;
    font-family:sans-serif; z-index:5; max-width:450px;
    border: 2px solid #333;
    backdrop-filter: blur(10px);
    max-height: 90vh;
    overflow-y: auto;
    transition: transform 0.3s ease;
  }
  #controls.collapsed {
    transform: translateX(-85%);
  }
  #controls.collapsed:hover {
    transform: translateX(-5%);
  }
  .main-collapse-btn {
    position: absolute;
    top: 10px;
    right: -40px;
    background: rgba(0,0,0,0.8);
    border: 2px solid #333;
    color: white;
    padding: 8px 12px;
    border-radius: 0 10px 10px 0;
    cursor: pointer;
    font-size: 16px;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }
  .main-collapse-btn:hover {
    background: rgba(50,50,50,0.9);
  }
  #controls label { display:block; margin-top:8px; font-size:12px; }
  #controls input[type="range"] { width:100%; }
  #controls select { width:100%; margin-top:4px; }
  
  
  /* Collapsible Panel Styles */
  .panel-header {
    background: rgba(50,50,50,0.8);
    padding: 10px;
    border-radius: 5px;
    margin: 8px 0 4px 0;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border: 1px solid #555;
    transition: background-color 0.3s;
  }
  .panel-header:hover {
    background: rgba(70,70,70,0.8);
  }
  .panel-header.collapsed {
    margin-bottom: 8px;
  }
  .panel-content {
    margin-left: 10px;
    border-left: 2px solid #555;
    padding-left: 10px;
    transition: max-height 0.3s ease;
    overflow: hidden;
  }
  .panel-content.collapsed {
    max-height: 0;
    padding: 0 0 0 10px;
    margin: 0;
  }
  .panel-arrow {
    transition: transform 0.3s;
    font-size: 14px;
  }
  .panel-arrow.collapsed {
    transform: rotate(-90deg);
  }
  
  canvas { position:absolute; top:0; left:0; width:100%; height:100%; }
  .status-indicator {
    display: inline-block; width: 12px; height: 12px; border-radius: 50%;
    margin-right: 8px; background: #ff4444;
  }
  .status-indicator.active { background: #44ff44; }
  .hand-info {
    background: rgba(255,255,255,0.1); padding: 8px; border-radius: 5px;
    margin-top: 10px; font-size: 11px;
  }
  .progress { background: rgba(255,255,255,0.2); padding: 5px; border-radius: 3px; margin-top: 5px; }
  .gesture-status {
    background: rgba(100,255,100,0.2); padding: 8px; border-radius: 5px;
    margin-top: 10px; font-size: 12px; border: 1px solid #4f4;
  }
  .active-sounds {
    background: rgba(255,200,0,0.2); padding: 6px; border-radius: 5px;
    margin-top: 8px; font-size: 11px; border: 1px solid #fc0;
  }
  .visual-controls {
    background: rgba(255,0,255,0.2); padding: 8px; border-radius: 5px;
    margin-top: 8px; font-size: 11px; border: 1px solid #f0f;
  }
</style>
</head>
<body>
<div id="controls">
  <button class="main-collapse-btn" id="main-collapse-btn">‚óÄ</button>
  <div style="display: flex; align-items: center; margin-bottom: 10px;">
    <h2 style="margin: 0; flex: 1;">üéπ Glass Composer v3</h2>
    <div class="status-indicator" id="model-status"></div>
  </div>
  

  
  <!-- System Info Panel -->
  <div class="panel-header" id="system-header">
    <span>üéõÔ∏è FM Synthesizer Information</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="system-panel">
    <div class="hand-info">
      <div>üéº <strong>FM Synth v3:</strong> Philip Glass Composition Engine</div>
      <div id="hand-detection-status">Loading ML5.js HandPose model...</div>
      <div class="progress">
        ‚úÖ Gesture-controlled dual-layer composition<br>
        ‚úÖ Left hand: Harmonic backing chords<br>
        ‚úÖ Right hand: Melodic arpeggios<br>
        ‚úÖ Philip Glass additive processes<br>
        ‚úÖ Independent layer timing<br>
        ‚úÖ Minimalist pattern evolution
      </div>
    </div>
  </div>

  <!-- FM Synthesis Controls Panel -->
  <div class="panel-header" id="fm-header">
    <span>üì° FM Synthesis Engine</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="fm-panel">
    <div class="visual-controls" style="border-color: #f84;">
      <strong>üéõÔ∏è FM Parameters:</strong><br>
      <label>Carrier Ratio: <span id="carrierRatioVal">1.0</span>
        <input type="range" id="carrierRatio" min="0.5" max="4.0" step="0.1" value="1.0">
      </label>
      <label>Modulator Ratio: <span id="modulatorRatioVal">1.0</span>
        <input type="range" id="modulatorRatio" min="0.1" max="8.0" step="0.1" value="1.0">
      </label>
      <label>Modulation Index: <span id="modulationIndexVal">2.0</span>
        <input type="range" id="modulationIndex" min="0" max="10" step="0.1" value="2.0">
      </label>
      <label>Feedback Amount: <span id="feedbackVal">0.0</span>
        <input type="range" id="feedback" min="0" max="0.9" step="0.05" value="0.0">
      </label>
    </div>
  </div>

  <!-- Gesture Controls Panel -->
  <div class="panel-header" id="gesture-header">
    <span>ü§ö FM Gesture Mapping</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="gesture-panel">
    <div class="gesture-status">
             <strong>ü§ö Left Hand (Harmonic Backing):</strong><br>
       ‚Ä¢ X-axis: Chord inversion/voicing<br>
       ‚Ä¢ Y-axis: Root note (chromatic scale)<br>
       ‚Ä¢ Distance: Backing volume<br>
       ‚Ä¢ Fingers: Chord complexity (triad to extended)<br>
       <br>
       <strong>üëâ Right Hand (Melodic Arpeggios):</strong><br>
       ‚Ä¢ X-axis: Pattern complexity/speed<br>
       ‚Ä¢ Y-axis: Melodic range (octave)<br>
       ‚Ä¢ Distance: Arpeggio volume<br>
       ‚Ä¢ Fingers: Additive process control<br>
      <div id="gesture-feedback">Show hands to see FM parameters...</div>
    </div>

    <div class="active-sounds">
      <strong>üéµ Active FM Operators:</strong>
      <div id="sound-layers">None</div>
    </div>
  </div>

  <!-- Musical Scale Panel -->
  <div class="panel-header" id="scale-header">
    <span>üéº Musical Scales</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="scale-panel">
    <label>Scale Type:
      <select id="scaleType">
        <option value="chromatic">Chromatic (All Notes)</option>
        <option value="major" selected>Major Scale</option>
        <option value="minor">Minor Scale</option>
        <option value="pentatonic">Pentatonic</option>
        <option value="colundi">Colundi (Modal)</option>
      </select>
    </label>
    <label>Root Note:
      <select id="rootNote">
        <option value="C">C</option>
        <option value="C#">C# / Db</option>
        <option value="D">D</option>
        <option value="D#">D# / Eb</option>
        <option value="E">E</option>
        <option value="F">F</option>
        <option value="F#">F# / Gb</option>
        <option value="G">G</option>
        <option value="G#">G# / Ab</option>
        <option value="A" selected>A</option>
        <option value="A#">A# / Bb</option>
        <option value="B">B</option>
      </select>
    </label>
    <div id="scale-info" style="font-size: 10px; color: #aaa; margin-top: 5px;">
      Current scale: A Major
    </div>
  </div>

  <!-- Visual Effects Panel -->
  <div class="panel-header" id="visual-header">
    <span>üåà Visual Effects</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="visual-panel">
    <div class="visual-controls">
      <strong>üåà Visual Effects:</strong><br>
      <label>Effect Intensity: <span id="effectIntensityVal">0.7</span>
        <input type="range" id="effectIntensity" min="0.1" max="1" step="0.1" value="0.7">
      </label>
      <label>Hand Glow Size: <span id="handGlowVal">30</span>
        <input type="range" id="handGlow" min="10" max="60" step="5" value="30">
      </label>
    </div>

    <div class="visual-controls" style="border-color: #0ff;">
      <strong>üìè Volume Calibration:</strong><br>
      <label>Close Hand Distance (100% vol): <span id="maxDistanceVal">120</span>
        <input type="range" id="maxDistance" min="100" max="800" step="10" value="120">
      </label>
      <label>Far Hand Distance (0% vol): <span id="minDistanceVal">40</span>
        <input type="range" id="minDistance" min="10" max="200" step="5" value="40">
      </label>
      <div id="distance-debug" style="font-size: 10px; color: #0ff; margin-top: 5px;">
        Current distances will appear here...
      </div>
    </div>
  </div>



  <!-- Left Hand Controls Panel -->
  <div class="panel-header" id="left-header">
    <span>üëà Left Hand - Carrier Oscillator</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="left-panel">
    <label>Carrier Waveform:
      <select id="leftWaveform">
        <option value="sine" selected>Sine Wave</option>
        <option value="triangle">Triangle Wave</option>
        <option value="sawtooth">Sawtooth Wave</option>
        <option value="square">Square Wave</option>
      </select>
    </label>
    <label>Base Frequency: <span id="leftBasePitchVal">220</span> Hz
      <input type="range" id="leftBasePitch" min="80" max="800" value="220">
    </label>
    <label>Frequency Range: <span id="leftPitchRangeVal">600</span> Hz
      <input type="range" id="leftPitchRange" min="200" max="1200" value="600">
    </label>
    <label>Carrier Amplitude: <span id="leftMaxGainVal">0.4</span>
      <input type="range" id="leftMaxGain" min="0" max="1" step="0.01" value="0.4">
    </label>
    <label>Attack Time: <span id="carrierAttackVal">0.05</span>s
      <input type="range" id="carrierAttack" min="0.01" max="0.5" step="0.01" value="0.05">
    </label>
  </div>

  <!-- Right Hand Controls Panel -->
  <div class="panel-header" id="right-header">
    <span>üëâ Right Hand - Modulator Oscillator</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="right-panel">
    <label>Modulator Waveform:
      <select id="rightWaveform">
        <option value="sine" selected>Sine Wave</option>
        <option value="triangle">Triangle Wave</option>
        <option value="sawtooth">Sawtooth Wave</option>
        <option value="square">Square Wave</option>
      </select>
    </label>
    <label>Modulator Amplitude: <span id="rightMaxGainVal">0.3</span>
      <input type="range" id="rightMaxGain" min="0" max="1" step="0.01" value="0.3">
    </label>
    <label>Frequency Range: <span id="rightPitchRangeVal">8.0</span> ratio
      <input type="range" id="rightPitchRange" min="0.5" max="16" step="0.1" value="8.0">
    </label>
    <label>Modulation Depth: <span id="rightModDepthVal">100</span> Hz
      <input type="range" id="rightModDepth" min="0" max="500" step="10" value="100">
    </label>
    <label>Release Time: <span id="modulatorReleaseVal">0.3</span>s
      <input type="range" id="modulatorRelease" min="0.1" max="2.0" step="0.1" value="0.3">
    </label>
  </div>

  <!-- Philip Glass Composition Panel -->
  <div class="panel-header" id="arpeggio-header">
    <span>üéπ Philip Glass Engine</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="arpeggio-panel">
    <div class="visual-controls" style="border-color: #4f4;">
      <strong>üéπ Minimalist Composition:</strong><br>
      <label>Arpeggio Speed: <span id="arpeggioSpeedVal">150</span> ms
        <input type="range" id="arpeggioSpeed" min="80" max="500" step="20" value="150">
      </label>
      <label>Backing Chord Type:
        <select id="chordType">
          <option value="major" selected>Major Triad</option>
          <option value="minor">Minor Triad</option>
          <option value="maj7">Major 7th</option>
          <option value="min7">Minor 7th</option>
          <option value="sus4">Suspended 4th</option>
          <option value="add9">Add 9</option>
        </select>
      </label>
      <label>Melodic Pattern:
        <select id="arpeggioPattern">
          <option value="glass_additive" selected>Glass Additive</option>
          <option value="glass_cycle">Glass Cycle</option>
          <option value="up">Simple Up</option>
          <option value="updown">Up-Down</option>
          <option value="cascade">Cascade Build</option>
          <option value="polyrhythm">Polyrhythmic</option>
        </select>
      </label>
      <label>Composition Mode:
        <input type="checkbox" id="arpeggioEnabled" checked> Dual Layer Mode
      </label>
      <div id="arpeggio-status" style="font-size: 11px; color: #4f4; margin-top: 5px;">
        Glass Engine: Major Additive at 150ms
      </div>
      <div id="chord-display" style="font-size: 10px; color: #aaa; margin-top: 5px;">
        Left hand: Chord backing | Right hand: Melodic line
      </div>
    </div>
  </div>

  <!-- Global Settings Panel -->
  <div class="panel-header" id="global-header">
    <span>‚öôÔ∏è Global Settings</span>
    <span class="panel-arrow">‚ñº</span>
  </div>
  <div class="panel-content" id="global-panel">
    <label>Master Volume: <span id="masterVolumeVal">0.7</span>
      <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.7">
    </label>
    <label>Smoothing: <span id="smoothingVal">0.15</span>
      <input type="range" id="smoothing" min="0.01" max="0.5" step="0.01" value="0.15">
    </label>
  </div>
</div>

<video id="video" autoplay playsinline style="display:none"></video>
<canvas id="video-canvas"></canvas>
<canvas id="overlay-canvas"></canvas>

<!-- ML5.js library -->
<script src="https://unpkg.com/ml5@latest/dist/ml5.min.js"></script>

<script>
(async () => {
  // Debug logging - Updated for FM synthesizer v3
  function debugLog(message, data = null) {
    console.log(`[FM-Synth-v3] ${message}`, data || '');
  }

  debugLog('Initializing Complete Gesture Theremin v5 - Onboarding & Scales');

  // DOM elements
  const video = document.getElementById('video');
  const vcanvas = document.getElementById('video-canvas'), vctx = vcanvas.getContext('2d');
  const ocanvas = document.getElementById('overlay-canvas'), octx = ocanvas.getContext('2d');

  const modelStatus = document.getElementById('model-status');
  const handDetectionStatus = document.getElementById('hand-detection-status');
  const gestureFeedback = document.getElementById('gesture-feedback');
  const soundLayers = document.getElementById('sound-layers');

  // Control elements - Updated for FM synthesis
  const ctrl = {};
  ['leftWaveform', 'leftBasePitch', 'leftPitchRange', 'leftMaxGain', 'carrierAttack',
   'rightWaveform', 'rightMaxGain', 'rightPitchRange', 'rightModDepth', 'modulatorRelease', 
   'carrierRatio', 'modulatorRatio', 'modulationIndex', 'feedback',
   'masterVolume', 'smoothing', 'effectIntensity', 'handGlow', 'maxDistance', 'minDistance',
   'scaleType', 'rootNote', 'arpeggioSpeed', 'chordType', 'arpeggioPattern', 'arpeggioEnabled'].forEach(id => {
    ctrl[id] = document.getElementById(id);
  });
  
  // Debug: Log successful control initialization per rules
  debugLog('‚úÖ FM synthesizer controls initialized with new parameters');

  // Additional DOM elements for calibration
  const distanceDebug = document.getElementById('distance-debug');
  const scaleInfo = document.getElementById('scale-info');

  // Main collapse button
  const mainCollapseBtn = document.getElementById('main-collapse-btn');

  // Face detection variables (for mask effect, not mouth tracking)
  let facemesh = null;
  let faceDetections = [];

  // Mobile detection and main collapse functionality
  function isMobile() {
    return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           window.innerWidth <= 768;
  }

  // Initialize collapse state based on device
  let isMainCollapsed = isMobile();

  // Main menu collapse functionality
  function toggleMainCollapse() {
    isMainCollapsed = !isMainCollapsed;
    const controls = document.getElementById('controls');
    
    if (isMainCollapsed) {
      controls.classList.add('collapsed');
      mainCollapseBtn.textContent = '‚ñ∂';
      debugLog('üéõÔ∏è Controls panel collapsed');
    } else {
      controls.classList.remove('collapsed');
      mainCollapseBtn.textContent = '‚óÄ';
      debugLog('üéõÔ∏è Controls panel expanded');
    }
  }

  // COLLAPSIBLE PANEL SYSTEM - Updated for FM synthesis panels
  function initializePanels() {
    const headers = ['system', 'fm', 'gesture', 'scale', 'visual', 'left', 'right', 'arpeggio', 'global'];
    
    headers.forEach(name => {
      const header = document.getElementById(`${name}-header`);
      const panel = document.getElementById(`${name}-panel`);
      const arrow = header.querySelector('.panel-arrow');
      
      if (!header || !panel || !arrow) {
        debugLog(`‚ö†Ô∏è Panel ${name} not found - skipping`);
        return; // Skip if elements don't exist
      }
      
      // Start with some panels collapsed to save space
      // Keep FM panel expanded by default for easy access
      if (['left', 'right', 'global', 'visual'].includes(name)) {
        panel.classList.add('collapsed');
        header.classList.add('collapsed');
        arrow.classList.add('collapsed');
      }
      
      header.onclick = () => {
        const isCollapsed = panel.classList.contains('collapsed');
        
        if (isCollapsed) {
          panel.classList.remove('collapsed');
          header.classList.remove('collapsed');
          arrow.classList.remove('collapsed');
        } else {
          panel.classList.add('collapsed');
          header.classList.add('collapsed');
          arrow.classList.add('collapsed');
        }
        
        debugLog(`üì± Panel ${name} ${isCollapsed ? 'expanded' : 'collapsed'}`);
      };
    });
    
    debugLog('‚úÖ FM synthesizer panels initialized with debug logging per rules');
  }

  // MUSICAL SCALE SYSTEM
  const scaleDefinitions = {
    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], // All semitones
    major: [0, 2, 4, 5, 7, 9, 11], // Major scale intervals
    minor: [0, 2, 3, 5, 7, 8, 10], // Natural minor scale
    pentatonic: [0, 2, 4, 7, 9], // Major pentatonic
    colundi: [0, 1, 3, 5, 6, 8, 10] // Locrian mode (colundi approximation)
  };

  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  
  function noteToFrequency(noteIndex) {
    // A4 = 440Hz at index 57 (A4 in MIDI)
    const A4_INDEX = 57;
    const A4_FREQ = 440;
    return A4_FREQ * Math.pow(2, (noteIndex - A4_INDEX) / 12);
  }

  function quantizeToScale(frequency) {
    const scaleType = ctrl.scaleType.value;
    const rootNote = ctrl.rootNote.value;
    
    if (scaleType === 'chromatic') {
      // No quantization for chromatic
      return frequency;
    }
    
    // Find the closest MIDI note
    const midiNote = Math.round(12 * Math.log2(frequency / 440) + 69);
    
    // Get root note index (C = 0, C# = 1, etc.)
    const rootIndex = noteNames.indexOf(rootNote);
    
    // Get scale intervals
    const scaleIntervals = scaleDefinitions[scaleType];
    
    // Find the closest note in the scale
    let closestNote = midiNote;
    let minDistance = Infinity;
    
    // Check all octaves around the target note
    for (let octave = -2; octave <= 2; octave++) {
      scaleIntervals.forEach(interval => {
        const scaleNote = rootIndex + interval + (octave * 12) + Math.floor((midiNote - rootIndex) / 12) * 12;
        const distance = Math.abs(midiNote - scaleNote);
        
        if (distance < minDistance) {
          minDistance = distance;
          closestNote = scaleNote;
        }
      });
    }
    
    return noteToFrequency(closestNote);
  }

  function updateScaleInfo() {
    const scaleType = ctrl.scaleType.value;
    const rootNote = ctrl.rootNote.value;
    scaleInfo.textContent = `Current scale: ${rootNote} ${scaleType.charAt(0).toUpperCase() + scaleType.slice(1)}`;
  }

  // Scale control event listeners
  ctrl.scaleType.onchange = updateScaleInfo;
  ctrl.rootNote.onchange = updateScaleInfo;

  // Canvas sizing
  let width = window.innerWidth, height = window.innerHeight;
  [vcanvas, ocanvas].forEach(c => { c.width = width; c.height = height; });

  // Set dynamic distance values based on screen height
  function updateDistanceCalibration() {
    const maxDistance = height * 0.7;     // Close hand = 70% of screen height (100% vol)
    const minDistance = height * 0.1;     // Far hand = 10% of screen height (0% vol)
    
    // Update control values
    ctrl.maxDistance.value = maxDistance;
    ctrl.minDistance.value = minDistance;
    
    // Update the displayed values
    document.getElementById('maxDistanceVal').textContent = Math.round(maxDistance);
    document.getElementById('minDistanceVal').textContent = Math.round(minDistance);
    
    // Update slider ranges to accommodate the new values
    ctrl.maxDistance.max = Math.max(maxDistance * 1.5, 800);
    ctrl.minDistance.max = Math.max(minDistance * 3, 200);
    
    debugLog(`üìè Dynamic distance calibration: Close=${maxDistance}px, Far=${minDistance}px (based on screen height: ${height}px)`);
  }
  
  updateDistanceCalibration();
  
  // Bind control values to display spans
  function bind(id, spanId) {
    const inp = document.getElementById(id), span = document.getElementById(spanId);
    if (!inp || !span) return;
    span.innerText = inp.value;
    inp.oninput = () => span.innerText = inp.value;
  }

  // Bind all controls
  ['leftBasePitch', 'leftPitchRange', 'leftLfoDepth', 'leftMaxGain',
   'rightMaxGain', 'rightPitchRange', 'rightMinPitch', 'rightReverbWet',
   'masterVolume', 'smoothing', 'effectIntensity', 'handGlow', 'maxDistance', 'minDistance',
   'arpeggioSpeed'].forEach(id => {
    bind(id, id + 'Val');
  });

  // FM SYNTHESIS AUDIO SYSTEM - Core implementation per rules
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let masterGainNode;
  let activeSounds = new Map();
  let soundIdCounter = 0;

  // Smooth value transitions for FM parameters
  class SmoothedValue {
    constructor(initialValue = 0, smoothing = 0.15) {
      this.value = initialValue;
      this.target = initialValue;
      this.smoothing = smoothing;
    }
    
    update(newTarget, customSmoothing = null) {
      this.target = newTarget;
      const alpha = customSmoothing !== null ? customSmoothing : this.smoothing;
      this.value = alpha * this.target + (1 - alpha) * this.value;
      return this.value;
    }
  }

  // FM Synthesis Sound Layer - Implements true frequency modulation
  class FMSoundLayer {
    constructor(id, hand) {
      this.id = id;
      this.hand = hand; // Store hand data for gesture mapping
      this.active = false;
      this.sustained = false;
      
      // Visual properties for frozen representation
      this.frozenPosition = null;
      this.frozenColor = null;
      this.frozenParams = null;
      
             // FM synthesis parameters with smooth interpolation - Added vibrato and operator support
       this.params = {
         carrierFreq: new SmoothedValue(220, 0.2),
         modulatorRatio: new SmoothedValue(1.0, 0.15),
         modulationIndex: new SmoothedValue(2.0, 0.15),
         masterVolume: new SmoothedValue(0, 0.2),
         feedback: new SmoothedValue(0.15, 0.15), // Start with some feedback for immediate sound
         vibratoDepth: new SmoothedValue(0, 0.15),
         operatorCount: new SmoothedValue(1, 0.3)
       };
      
      debugLog(`üéõÔ∏è Creating FM sound layer #${this.id} with carrier + modulator`);
      this.createFMAudioNodes();
    }
    
    createFMAudioNodes() {
      try {
        // Create carrier oscillator (main sound)
        this.carrier = audioCtx.createOscillator();
        this.carrier.type = ctrl.leftWaveform ? ctrl.leftWaveform.value : 'sine';
        
        // Create modulator oscillator (FM source)
        this.modulator = audioCtx.createOscillator();
        this.modulator.type = ctrl.rightWaveform ? ctrl.rightWaveform.value : 'sine';
        
        // Create modulation depth control (modulation index)
        this.modulationGain = audioCtx.createGain();
        this.modulationGain.gain.value = 0;
        
        // Create feedback delay for more complex FM timbres
        this.feedbackDelay = audioCtx.createDelay(0.01);
        this.feedbackDelay.delayTime.value = 0.001; // Very short delay
        this.feedbackGain = audioCtx.createGain();
        this.feedbackGain.gain.value = 0;
        
        // Create envelope controls
        this.masterGain = audioCtx.createGain();
        this.masterGain.gain.value = 0;
        
                 // Create vibrato LFO for musical expression
         this.vibratoLFO = audioCtx.createOscillator();
         this.vibratoLFO.type = 'sine';
         this.vibratoLFO.frequency.value = 5; // 5Hz vibrato
         this.vibratoGain = audioCtx.createGain();
         this.vibratoGain.gain.value = 0; // Start with no vibrato
         
         // Create filter for timbral shaping
         this.filter = audioCtx.createBiquadFilter();
         this.filter.type = 'lowpass';
         this.filter.frequency.value = 2000;
         this.filter.Q.value = 1;
        
                 // Connect FM synthesis chain:
         // Modulator -> Modulation Gain -> Carrier frequency (FM!)
         this.modulator.connect(this.modulationGain);
         this.modulationGain.connect(this.carrier.frequency);
         
         // Connect vibrato LFO to carrier frequency for musical expression
         this.vibratoLFO.connect(this.vibratoGain);
         this.vibratoGain.connect(this.carrier.frequency);
        
        // Add feedback loop for richer harmonics
        this.carrier.connect(this.feedbackDelay);
        this.feedbackDelay.connect(this.feedbackGain);
        this.feedbackGain.connect(this.carrier.frequency);
        
        // Main signal path: Carrier -> Filter -> Master Gain -> Output
        this.carrier.connect(this.filter);
        this.filter.connect(this.masterGain);
        this.masterGain.connect(masterGainNode);
        
                 // Start oscillators and vibrato LFO
         this.carrier.start();
         this.modulator.start();
         this.vibratoLFO.start();
        
        debugLog(`‚úÖ FM synthesis chain created for layer #${this.id}: Modulator->Carrier with feedback`);
        
      } catch (error) {
        debugLog(`‚ùå Error creating FM audio nodes for layer #${this.id}:`, error);
      }
    }
    
         // Update FM parameters based on hand gestures - New finger count mapping
     updateFromGestures(leftHand, rightHand) {
       if (!this.carrier || !this.modulator) return;
       
       try {
         // Left hand controls carrier frequency, volume, and harmonic content - SWAPPED X/Y
         if (leftHand) {
           // Map Y position to carrier frequency within musical scale (VERTICAL = FREQUENCY)
           const baseFreq = parseFloat(ctrl.leftBasePitch?.value || 220);
           const freqRange = parseFloat(ctrl.leftPitchRange?.value || 600);
           const rawFreq = baseFreq + ((1 - leftHand.y / height) * freqRange); // Inverted Y for musical feel
           
           // Quantize to musical scale
           const carrierFreq = quantizeToScale(rawFreq);
           this.params.carrierFreq.update(carrierFreq);
           
           // Map X position to modulation index (FM depth) - HORIZONTAL = MOD INDEX
           const modIndex = (leftHand.x / width) * 10; // 0-10 range
           this.params.modulationIndex.update(modIndex);
           
           // Distance controls master volume
           const volume = leftHand.z * parseFloat(ctrl.leftMaxGain?.value || 0.4);
           this.params.masterVolume.update(volume);
           
           // NEW: Finger count controls arpeggio chord range for musical expression
           const fingerCount = leftHand.fingerCount || 1;
           // Store finger count for arpeggio generation (used in handleFMGestures)
           this.arpeggioFingerCount = fingerCount;
           debugLog(`üñêÔ∏è Left hand: ${fingerCount} fingers = ${fingerCount} octave arpeggio range`);
         }
         
         // Right hand controls modulator ratio, feedback, and filter resonance - SWAPPED X/Y
         if (rightHand) {
           // Map Y position to modulator frequency ratio (VERTICAL = RATIO)
           const ratioRange = parseFloat(ctrl.rightPitchRange?.value || 8);
           const modulatorRatio = 0.1 + ((1 - rightHand.y / height) * ratioRange); // Inverted Y
           this.params.modulatorRatio.update(modulatorRatio);
           
           // Map X position to feedback amount (HORIZONTAL = FEEDBACK)
           const feedbackAmount = 0.1 + (rightHand.x / width) * 0.2; // Start at 0.1, range 0.1-0.3
           this.params.feedback.update(feedbackAmount);
           
           // NEW: Finger count controls FM operator complexity
           const fingerCount = rightHand.fingerCount || 1;
           const operatorCount = fingerCount; // 1-5 operators
           this.params.operatorCount.update(operatorCount);
           debugLog(`üñêÔ∏è Right hand: ${fingerCount} fingers = ${operatorCount} FM operators`);
         }
         
         // Apply all parameter updates to audio nodes
         this.applyFMParameters();
         
       } catch (error) {
         debugLog(`‚ùå Error updating FM parameters for layer #${this.id}:`, error);
       }
     }
    
         // Apply calculated FM parameters to Web Audio nodes - Updated for finger count control
     applyFMParameters() {
       const now = audioCtx.currentTime;
       
       // Set carrier frequency
       this.carrier.frequency.setTargetAtTime(
         this.params.carrierFreq.value, now, 0.02
       );
       
       // Set modulator frequency (carrier frequency * ratio)
       const modulatorFreq = this.params.carrierFreq.value * this.params.modulatorRatio.value;
       this.modulator.frequency.setTargetAtTime(modulatorFreq, now, 0.02);
       
       // Set modulation depth (frequency range modulated by modulator)
       const modDepth = this.params.carrierFreq.value * this.params.modulationIndex.value;
       this.modulationGain.gain.setTargetAtTime(modDepth, now, 0.02);
       
       // Set feedback amount for harmonic complexity
       this.feedbackGain.gain.setTargetAtTime(this.params.feedback.value, now, 0.02);
       
       // Set master volume
       this.masterGain.gain.setTargetAtTime(this.params.masterVolume.value, now, 0.02);
       
       // NEW: Apply operator count controls (vibrato removed for arpeggio mode)
       
       // Filter cutoff based on modulation index and operator count
       const baseFilterFreq = 500 + (this.params.modulationIndex.value / 10) * 3000;
       const operatorMultiplier = 1 + (this.params.operatorCount.value - 1) * 0.3; // More operators = brighter
       this.filter.frequency.setTargetAtTime(baseFilterFreq * operatorMultiplier, now, 0.05);
       
       // Operator count affects filter resonance for complexity
       const operatorQ = 1 + (this.params.operatorCount.value - 1) * 2; // 1-9 Q range
       this.filter.Q.setTargetAtTime(operatorQ, now, 0.05);
     }
    
    // Freeze the visual and audio state when sustained
    freezeState(hand) {
      this.frozenPosition = { x: hand.x, y: hand.y };
      this.frozenParams = {
        carrierFreq: this.params.carrierFreq.value,
        modulatorRatio: this.params.modulatorRatio.value,
        modulationIndex: this.params.modulationIndex.value
      };
      this.frozenColor = `hsl(${(this.frozenParams.carrierFreq / 1000) * 360}, 80%, 60%)`;
      debugLog(`üßä Frozen FM layer #${this.id} at ${this.frozenParams.carrierFreq.toFixed(1)}Hz`);
    }
    
    // Clean up audio nodes when destroying layer
    destroy() {
      debugLog(`üóëÔ∏è Destroying FM layer #${this.id}`);
      
      try {
        // Fade out quickly
        this.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02);
        
        setTimeout(() => {
          try {
            this.carrier.stop();
            this.modulator.stop();
            this.masterGain.disconnect();
          } catch (e) {
            debugLog(`‚ö†Ô∏è Error stopping oscillators for layer #${this.id}:`, e);
          }
        }, 50);
      } catch (error) {
        debugLog(`‚ùå Error destroying FM layer #${this.id}:`, error);
      }
    }
  }

  // Initialize audio system - Auto-start when hands detected
  let audioStarted = false;

  // [FM-Synth-v3] Arpeggio System Variables
  let arpeggioLayers = new Map(); // Multiple arpeggio voices
  let arpeggioInterval = null;
  let currentArpeggioStep = 0;
  let isArpeggioPlaying = false;
  let lastHandsDetectedTime = 0;
  let autoStartThreshold = 2000; // 2 seconds of hand detection before auto-starting audio

  // [FM-Synth-v3] Philip Glass Dual-Layer System
  let backingChordLayer = null; // Sustained chord backing (left hand)
  let melodicArpeggioLayers = new Map(); // Arpeggio melody (right hand)
  let backingGainNode = null;
  let melodicGainNode = null;
  let currentBackingChord = null;
  let lastLeftHandState = { rootNote: null, fingerCount: 0, x: 0 };
  let lastRightHandState = { fingerCount: 0, y: 0, x: 0 };
  
  // Glass composition state
  let additiveStage = 0; // For additive processes
  let cyclePhase = 0; // For cycling patterns

  // Chord definitions for Philip Glass-style composition
  const chordDefinitions = {
    major: [0, 4, 7], // Root, Major 3rd, Perfect 5th
    minor: [0, 3, 7], // Root, Minor 3rd, Perfect 5th
    maj7: [0, 4, 7, 11], // Major 7th chord
    min7: [0, 3, 7, 10], // Minor 7th chord
    sus4: [0, 5, 7], // Suspended 4th chord
    add9: [0, 4, 7, 14], // Add 9 chord (like Glass often uses)
  };

  // Philip Glass-style pattern generators
  const arpeggioPatterns = {
    glass_additive: (chordNotes) => {
      // Glass additive process: start with one note, gradually add more
      const patterns = [];
      for (let i = 1; i <= chordNotes.length; i++) {
        const currentSet = chordNotes.slice(0, i);
        // Repeat each additive stage multiple times
        for (let repeat = 0; repeat < 4; repeat++) {
          patterns.push(...currentSet);
        }
      }
      return patterns;
    },
    glass_cycle: (chordNotes) => {
      // Glass cycling pattern: different cycle lengths creating phase shifts
      const cycle1 = [chordNotes[0], chordNotes[1], chordNotes[2]];
      const cycle2 = [chordNotes[1], chordNotes[2]];
      const combined = [];
      for (let i = 0; i < 12; i++) {
        combined.push(cycle1[i % cycle1.length]);
        if (i % 2 === 0) combined.push(cycle2[i % cycle2.length]);
      }
      return combined;
    },
    up: (chordNotes) => [...chordNotes],
    updown: (chordNotes) => [...chordNotes, ...chordNotes.slice(1, -1).reverse()],
    cascade: (chordNotes) => {
      const cascaded = [];
      chordNotes.forEach((note, i) => {
        for (let j = 0; j <= i; j++) {
          cascaded.push(chordNotes[j]);
        }
      });
      return cascaded;
    },
    polyrhythm: (chordNotes) => {
      // Create polyrhythmic pattern with different note durations
      const poly = [];
      chordNotes.forEach((note, i) => {
        const repeats = [3, 2, 4, 2][i % 4]; // Different cycle lengths
        for (let r = 0; r < repeats; r++) {
          poly.push(note);
        }
      });
      return poly;
    }
  };
  
  function initializeAudio() {
    debugLog('üéµ Audio system ready - will auto-start when hands detected');
    handDetectionStatus.textContent = 'üéµ Show hands to start FM synthesizer!';
  }
  
  function startAudioIfNeeded() {
    if (audioStarted) return;
    
    try {
      audioCtx.resume().then(() => {
        // Create master gain node
        masterGainNode = audioCtx.createGain();
        masterGainNode.connect(audioCtx.destination);
        masterGainNode.gain.value = parseFloat(ctrl.masterVolume?.value || 0.7);
        
        // Initialize Philip Glass dual-layer system
        initializeGlassSystem();
        
        audioStarted = true;
        debugLog('‚úÖ FM synthesis audio auto-started on hand detection');
        handDetectionStatus.textContent = 'FM synthesizer active - move hands to play!';
      }).catch(error => {
        debugLog('‚ùå Audio auto-start failed, click anywhere to start:', error);
        handDetectionStatus.textContent = 'Click anywhere to start audio, then show hands';
        
        // Fallback to click-to-start
        document.addEventListener('click', function startAudioOnClick() {
          audioCtx.resume().then(() => {
            masterGainNode = audioCtx.createGain();
            masterGainNode.connect(audioCtx.destination);
            masterGainNode.gain.value = parseFloat(ctrl.masterVolume?.value || 0.7);
            
            // Initialize Philip Glass dual-layer system
            initializeGlassSystem();
            
            audioStarted = true;
            debugLog('‚úÖ FM audio started after user click');
            handDetectionStatus.textContent = 'Audio started - show hands to play!';
          });
          document.removeEventListener('click', startAudioOnClick);
        }, { once: true });
      });
    } catch (error) {
      debugLog('‚ùå Audio system error:', error);
      handDetectionStatus.textContent = 'Audio not supported in this browser';
    }
  }

  // [FM-Synth-v3] Arpeggio System Implementation
  function generateChordFromBase(baseFreq, chordType, fingerCount) {
    // Use finger count to determine how many octaves up the chord goes
    const chordIntervals = chordDefinitions[chordType] || chordDefinitions.major;
    const octaveRange = Math.min(fingerCount, 3); // Max 3 octaves based on fingers
    
    const chordFrequencies = [];
    const baseNoteIndex = Math.round(12 * Math.log2(baseFreq / 440) + 69); // Convert to MIDI note
    
    chordIntervals.forEach(interval => {
      for (let octave = 0; octave <= octaveRange; octave++) {
        const noteIndex = baseNoteIndex + interval + (octave * 12);
        const frequency = noteToFrequency(noteIndex);
        chordFrequencies.push(frequency);
      }
    });
    
    // Limit to reasonable range and remove duplicates
    return [...new Set(chordFrequencies)]
      .filter(freq => freq >= 80 && freq <= 2000)
      .sort((a, b) => a - b);
  }

  function startArpeggio(baseFreq, leftHand, rightHand) {
    if (isArpeggioPlaying) stopArpeggio();
    
    const chordType = ctrl.chordType?.value || 'major';
    const fingerCount = leftHand?.fingerCount || 1;
    const pattern = ctrl.arpeggioPattern?.value || 'up';
    const speed = parseInt(ctrl.arpeggioSpeed?.value || 200);
    
    // Generate chord frequencies based on finger count
    const chordFreqs = generateChordFromBase(baseFreq, chordType, fingerCount);
    const arpeggioSequence = arpeggioPatterns[pattern](chordFreqs);
    
    debugLog(`üéº Starting arpeggio: ${chordType} ${pattern} with ${fingerCount} fingers, ${chordFreqs.length} notes`);
    
    // Ensure we have a tracking layer for state comparison
    if (!currentFMLayer) {
      currentFMLayer = {
        arpeggioFingerCount: fingerCount,
        lastRootNote: chordType,
        id: ++soundIdCounter
      };
    } else {
      currentFMLayer.arpeggioFingerCount = fingerCount;
      currentFMLayer.lastRootNote = chordType;
    }
    
    // Update UI display
    const chordDisplay = document.getElementById('chord-display');
    if (chordDisplay) {
             const chordNoteNames = chordFreqs.map(freq => {
         const noteIndex = Math.round(12 * Math.log2(freq / 440) + 69);
         const noteName = noteNames[noteIndex % 12];
         const octave = Math.floor(noteIndex / 12) - 1;
         return `${noteName}${octave}`;
       });
             chordDisplay.textContent = `Chord: ${chordNoteNames.join(' - ')}`;
    }
    
    currentArpeggioStep = 0;
    isArpeggioPlaying = true;
    
    // Start arpeggio sequencer
    arpeggioInterval = setInterval(() => {
      if (!arpeggioSequence.length) return;
      
      const currentFreq = arpeggioSequence[currentArpeggioStep % arpeggioSequence.length];
      
      // Create or update arpeggio note
      playArpeggioNote(currentFreq, leftHand, rightHand);
      
      currentArpeggioStep++;
      
      debugLog(`üéµ Arpeggio step ${currentArpeggioStep}: ${currentFreq.toFixed(1)}Hz`);
    }, speed);
    
    // Update status
    const arpeggioStatus = document.getElementById('arpeggio-status');
    if (arpeggioStatus) {
      arpeggioStatus.textContent = `Arpeggio: ${chordType} ${pattern} at ${speed}ms`;
    }
  }

  function stopArpeggio() {
    if (!isArpeggioPlaying) return;
    
    isArpeggioPlaying = false;
    if (arpeggioInterval) {
      clearInterval(arpeggioInterval);
      arpeggioInterval = null;
    }
    
    // Clean up arpeggio layers
    arpeggioLayers.forEach(layer => layer.destroy());
    arpeggioLayers.clear();
    
    debugLog('üéº Arpeggio stopped');
    
    const arpeggioStatus = document.getElementById('arpeggio-status');
    if (arpeggioStatus) {
      arpeggioStatus.textContent = 'Arpeggio: Stopped';
    }
  }

  function playArpeggioNote(frequency, leftHand, rightHand) {
    // Create short-lived FM layer for each arpeggio note
    const noteId = ++soundIdCounter;
    const arpeggioLayer = new FMSoundLayer(noteId, { left: leftHand, right: rightHand });
    
    // Override frequency for this arpeggio note
    arpeggioLayer.params.carrierFreq.value = frequency;
    arpeggioLayer.params.carrierFreq.target = frequency;
    
    // Apply current hand gesture parameters
    if (leftHand) {
      const volume = leftHand.z * parseFloat(ctrl.leftMaxGain?.value || 0.4);
      arpeggioLayer.params.masterVolume.update(volume * 0.6); // Reduce volume for arpeggio
      
      const modIndex = (leftHand.x / width) * 10;
      arpeggioLayer.params.modulationIndex.update(modIndex);
    }
    
    if (rightHand) {
      const modulatorRatio = 0.1 + ((1 - rightHand.y / height) * parseFloat(ctrl.rightPitchRange?.value || 8));
      arpeggioLayer.params.modulatorRatio.update(modulatorRatio);
      
      const feedback = 0.1 + (rightHand.x / width) * 0.2;
      arpeggioLayer.params.feedback.update(feedback);
    }
    
    // Apply parameters immediately
    arpeggioLayer.applyFMParameters();
    arpeggioLayer.active = true;
    arpeggioLayers.set(noteId, arpeggioLayer);
    
    // Schedule note cleanup (short duration for arpeggio effect)
    const noteDuration = Math.max(100, parseInt(ctrl.arpeggioSpeed?.value || 200) * 0.8);
    setTimeout(() => {
      if (arpeggioLayers.has(noteId)) {
        arpeggioLayer.destroy();
        arpeggioLayers.delete(noteId);
      }
    }, noteDuration);
  }

  function updateArpeggioSettings() {
    const arpeggioStatus = document.getElementById('arpeggio-status');
    const chordType = ctrl.chordType?.value || 'major';
    const pattern = ctrl.arpeggioPattern?.value || 'up';
    const speed = ctrl.arpeggioSpeed?.value || 200;
    
    if (arpeggioStatus) {
      arpeggioStatus.textContent = `Arpeggio: ${chordType} ${pattern} at ${speed}ms`;
    }
    
    debugLog(`üéº Arpeggio settings updated: ${chordType} ${pattern} at ${speed}ms`);
  }

  // [FM-Synth-v3] Philip Glass Dual-Layer System Implementation
  
  function initializeGlassSystem() {
    if (!audioCtx || !masterGainNode) return;
    
    // Create separate gain nodes for backing and melodic layers
    backingGainNode = audioCtx.createGain();
    backingGainNode.gain.value = 0.3; // Lower volume for backing
    backingGainNode.connect(masterGainNode);
    
    melodicGainNode = audioCtx.createGain();
    melodicGainNode.gain.value = 0.7; // Higher volume for melody
    melodicGainNode.connect(masterGainNode);
    
    debugLog('‚úÖ Philip Glass dual-layer system initialized');
  }

  function createSustainedBackingChord(baseFreq, chordType, fingerCount, leftHand) {
    // Clean up existing backing chord
    if (backingChordLayer) {
      backingChordLayer.forEach(osc => osc.stop());
    }
    
    const chordIntervals = chordDefinitions[chordType] || chordDefinitions.major;
    const baseNoteIndex = Math.round(12 * Math.log2(baseFreq / 440) + 69);
    
    // Create chord voicing based on finger count and X position (inversion)
    const inversionOffset = Math.floor((leftHand.x / width) * 3); // 0-2 inversions
    const octaveSpread = Math.min(fingerCount, 3); // 1-3 octaves
    
    backingChordLayer = [];
    chordIntervals.forEach((interval, i) => {
      for (let octave = 0; octave < octaveSpread; octave++) {
        const noteIndex = baseNoteIndex + interval + (octave * 12) + (inversionOffset * 12);
        const frequency = noteToFrequency(noteIndex);
        
        if (frequency >= 80 && frequency <= 800) { // Keep backing in lower register
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          
          osc.type = 'sine'; // Warm pad sound for backing
          osc.frequency.value = frequency;
          
          // Gentle attack for sustained backing
          gain.gain.setValueAtTime(0, audioCtx.currentTime);
          gain.gain.linearRampToValueAtTime(0.15 / chordIntervals.length, audioCtx.currentTime + 0.5);
          
          osc.connect(gain);
          gain.connect(backingGainNode);
          osc.start();
          
          backingChordLayer.push(osc);
        }
      }
    });
    
    debugLog(`üéπ Backing chord: ${chordType} with ${backingChordLayer.length} voices`);
  }

  function createMelodicArpeggio(baseFreq, pattern, rightHand) {
    if (isArpeggioPlaying) stopArpeggio();
    
    const chordType = ctrl.chordType?.value || 'major';
    const speed = parseInt(ctrl.arpeggioSpeed?.value || 150);
    
    // Right hand Y controls melodic range (octave)
    const octaveRange = 1 + Math.floor((1 - rightHand.y / height) * 2); // 1-3 octaves
    
    // Right hand X controls pattern complexity/speed modulation
    const complexityFactor = rightHand.x / width; // 0-1
    const speedModulation = 1 + (complexityFactor * 0.5); // 1.0 to 1.5x speed
    const adjustedSpeed = speed / speedModulation;
    
    // Generate melodic frequencies (higher register than backing)
    const baseNoteIndex = Math.round(12 * Math.log2(baseFreq / 440) + 69) + 12; // One octave up
    const chordIntervals = chordDefinitions[chordType] || chordDefinitions.major;
    const melodicFreqs = [];
    
    chordIntervals.forEach(interval => {
      for (let octave = 0; octave < octaveRange; octave++) {
        const noteIndex = baseNoteIndex + interval + (octave * 12);
        const frequency = noteToFrequency(noteIndex);
        if (frequency <= 2000) { // Keep melody in reasonable range
          melodicFreqs.push(frequency);
        }
      }
    });
    
    // Apply Glass pattern based on finger count (additive process)
    const fingerCount = rightHand.fingerCount || 1;
    let arpeggioSequence;
    
    if (pattern === 'glass_additive') {
      // Use finger count to control additive stage
      additiveStage = Math.min(fingerCount, melodicFreqs.length);
      const additiveMelody = melodicFreqs.slice(0, additiveStage);
      arpeggioSequence = arpeggioPatterns.glass_additive(additiveMelody);
    } else {
      arpeggioSequence = arpeggioPatterns[pattern](melodicFreqs);
    }
    
    debugLog(`üéµ Melodic arpeggio: ${pattern} with ${fingerCount} fingers, ${melodicFreqs.length} notes`);
    
    currentArpeggioStep = 0;
    isArpeggioPlaying = true;
    
    // Start melodic arpeggio sequencer
    arpeggioInterval = setInterval(() => {
      if (!arpeggioSequence.length) return;
      
      const currentFreq = arpeggioSequence[currentArpeggioStep % arpeggioSequence.length];
      playMelodicNote(currentFreq, rightHand);
      
      currentArpeggioStep++;
    }, adjustedSpeed);
    
    // Update status display
    const arpeggioStatus = document.getElementById('arpeggio-status');
    if (arpeggioStatus) {
      arpeggioStatus.textContent = `Glass Engine: ${chordType} ${pattern} at ${adjustedSpeed.toFixed(0)}ms`;
    }
  }

  function playMelodicNote(frequency, rightHand) {
    const noteId = ++soundIdCounter;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.type = 'triangle'; // Brighter sound for melody
    osc.frequency.value = frequency;
    
    // Quick attack/decay for arpeggio notes
    const volume = (rightHand.z || 0.5) * 0.3; // Controlled by right hand distance
    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
    
    osc.connect(gain);
    gain.connect(melodicGainNode);
    osc.start();
    
    melodicArpeggioLayers.set(noteId, { osc, gain });
    
    // Cleanup
    setTimeout(() => {
      osc.stop();
      melodicArpeggioLayers.delete(noteId);
    }, 350);
  }

  // Gesture state tracking for FM synthesis
  let gestureState = { active: false, leftHand: null, rightHand: null };
  let currentFMLayer = null;

  // Handle gesture-based FM synthesis control
  function handleFMGestures(hands) {
    const leftHand = hands.left;
    const rightHand = hands.right;
    
    // Auto-start audio when ANY hand is detected
    if ((leftHand || rightHand) && !audioStarted) {
      startAudioIfNeeded();
    }
    
    if (!masterGainNode) return;
    
         // Update gesture feedback display - Updated for Philip Glass composition
     let statusText = '';
     if (leftHand) {
       const rootNoteIndex = Math.floor((1 - leftHand.y / height) * 12);
       const rootNoteName = noteNames[rootNoteIndex];
       statusText += `üéπ LEFT: Root ${rootNoteName}, Fingers ${leftHand.fingerCount} | `;
     }
    
     if (rightHand) {
       const pattern = ctrl.arpeggioPattern?.value || 'glass_additive';
       const octaveRange = 1 + Math.floor((1 - rightHand.y / height) * 2);
       statusText += `üéµ RIGHT: ${pattern}, Range ${octaveRange} octaves`;
     }
    
             // [FM-Synth-v3] Arpeggio-based gesture handling
    const arpeggioEnabled = ctrl.arpeggioEnabled?.checked !== false;
    
    if (arpeggioEnabled && leftHand) {
      // Y-axis controls root note selection (map Y position to chromatic scale)
      const rootNoteIndex = Math.floor((1 - leftHand.y / height) * 12); // 0-11 for 12 chromatic notes
      const rootNoteName = noteNames[rootNoteIndex];
      
      // Update root note control to match hand position
      if (ctrl.rootNote && ctrl.rootNote.value !== rootNoteName) {
        ctrl.rootNote.value = rootNoteName;
        updateScaleInfo(); // Update the scale display
        debugLog(`üéº Root note changed to: ${rootNoteName}`);
      }
      
      // Calculate base frequency using current root note
      const baseFreq = noteToFrequency(69 + rootNoteIndex - 9); // A4=440Hz is index 69, A=9 in noteNames
      
      // Start or restart arpeggio with finger-controlled chord range
      if (!isArpeggioPlaying) {
        startArpeggio(baseFreq, leftHand, rightHand);
      } else {
        // Check if we need to update arpeggio due to finger count or root note change
        const needsUpdate = !currentFMLayer || 
                           currentFMLayer.arpeggioFingerCount !== leftHand.fingerCount ||
                           currentFMLayer.lastRootNote !== rootNoteName;
        
                 if (needsUpdate) {
           stopArpeggio();
           // Faster response time for finger changes
           setTimeout(() => {
             startArpeggio(baseFreq, leftHand, rightHand);
             // Store current state for comparison
             if (currentFMLayer) {
               currentFMLayer.arpeggioFingerCount = leftHand.fingerCount;
               currentFMLayer.lastRootNote = rootNoteName;
             }
             debugLog(`üéº Arpeggio updated: ${leftHand.fingerCount} fingers, root ${rootNoteName}`);
           }, 20); // Reduced from 50ms for faster response
         }
      }
      
    } else if (!arpeggioEnabled) {
      // Fallback to single FM layer mode when arpeggio is disabled
      if ((leftHand || rightHand) && !currentFMLayer) {
        startAudioIfNeeded();
        const newId = ++soundIdCounter;
        currentFMLayer = new FMSoundLayer(newId, { left: leftHand, right: rightHand });
        currentFMLayer.active = true;
        activeSounds.set(newId, currentFMLayer);
        debugLog(`üéµ New FM layer #${newId} created (arpeggio disabled)`);
      }
      
      if (currentFMLayer && currentFMLayer.active) {
        currentFMLayer.updateFromGestures(leftHand, rightHand);
      }
    }

    // Stop arpeggio when hands are removed
    if (!leftHand && !rightHand) {
      if (isArpeggioPlaying) {
        stopArpeggio();
      }
      if (currentFMLayer) {
        currentFMLayer.destroy();
        activeSounds.delete(currentFMLayer.id);
        currentFMLayer = null;
        debugLog(`üóëÔ∏è FM layer destroyed - no hands detected`);
      }
    }
    
    // Update UI displays
    gestureFeedback.textContent = statusText || 'Show hands to control Glass composition...';
    
    // Show Philip Glass dual-layer status
    if (arpeggioEnabled) {
      const backingStatus = currentBackingChord ? `Backing: ${currentBackingChord.chordType}` : 'No backing';
      const melodicStatus = isArpeggioPlaying ? `Melody: ${melodicArpeggioLayers.size} notes` : 'No melody';
      soundLayers.innerHTML = `Glass Mode: ${backingStatus} | ${melodicStatus}`;
    } else if (currentFMLayer) {
      soundLayers.innerHTML = `Single FM Layer #${currentFMLayer.id}`;
    } else {
      soundLayers.innerHTML = 'No active layers';
    }
  }

  // VIDEO AND HAND DETECTION SYSTEM - Restored for FM synthesizer
  let webcamRunning = false;
  let frameCount = 0;
  let handpose = null;
  let predictions = [];

  // Initialize camera and ML5 hand detection
  async function initializeCamera() {
    debugLog('üé• Requesting camera access for FM synthesizer...');
    
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { 
          width: 1280, 
          height: 720,
          facingMode: "user"
        } 
      });
      video.srcObject = stream; 
      await video.play();
      webcamRunning = true;
      debugLog('‚úÖ Camera access granted and video stream started');
      
             // Load ML5 hand pose model
       handpose = ml5.handPose({
         flipHorizontal: true,
         maxNumHands: 2,
         runtime: 'mediapipe',
         modelType: 'full'
       }, () => {
         debugLog('‚úÖ ML5.js HandPose model loaded successfully');
         // Turn status indicator GREEN when everything is working
         modelStatus.classList.add('active');
         handDetectionStatus.textContent = 'FM synthesizer ready - show hands to play!';
         detectHands();
       });
      
    } catch (error) {
      debugLog('‚ùå Error accessing camera:', error);
      handDetectionStatus.textContent = 'Camera access required for hand detection';
    }
  }

  // Hand detection loop
  async function detectHands() {
    if (handpose && webcamRunning) {
      try {
        predictions = await handpose.detect(video);
      } catch (error) {
        debugLog('Error during hand detection:', error);
        predictions = [];
      }
    }
    setTimeout(detectHands, 100);
  }

  // Process hand data for FM synthesis
  function processHands() {
    if (!predictions || predictions.length === 0) {
      return { left: null, right: null, headOutOfFrame: false };
    }

    const hands = predictions.map(pred => {
      if (!pred.keypoints || pred.keypoints.length === 0) return null;
      
      let sx = 0, sy = 0;
      pred.keypoints.forEach(kp => { sx += kp.x; sy += kp.y; });
      
      // Scale coordinates from video resolution to canvas size
      const rawX = sx / pred.keypoints.length;
      const rawY = sy / pred.keypoints.length;
      const scaledX = (rawX / 1280) * width;
      const scaledY = (rawY / 720) * height;
      
      // Simple finger count
      const fingerCount = countExtendedFingers(pred.keypoints);
      
      // Simple depth calculation based on hand size
      const depth = calculateHandDepth(pred.keypoints);
      
      return { 
        x: scaledX, 
        y: scaledY,
        z: depth,
        fingerCount: fingerCount,
        handedness: pred.handedness || 'Unknown'
      };
    }).filter(hand => hand !== null);

    // Assign left/right hands
    let left = null, right = null;
    if (hands.length === 1) {
      // Single hand - assign based on position or handedness
      const hand = hands[0];
      if (hand.handedness === 'Left') {
        left = hand;
      } else if (hand.handedness === 'Right') {
        right = hand;
      } else {
        // Fallback to position
        if (hand.x < width / 2) {
          right = hand;
        } else {
          left = hand;
        }
      }
    } else if (hands.length >= 2) {
      // Multiple hands - try handedness first
      hands.forEach(hand => {
        if (hand.handedness === 'Left') {
          left = hand;
        } else if (hand.handedness === 'Right') {
          right = hand;
        }
      });
      
      // Fallback to position if handedness failed
      if (!left && !right) {
        hands.sort((a, b) => a.x - b.x);
        right = hands[0];
        left = hands[hands.length - 1];
      }
    }

    return { left, right, headOutOfFrame: false };
  }

  // Simple finger counting - Enhanced sensitivity for arpeggio control
  function countExtendedFingers(keypoints) {
    if (!keypoints || keypoints.length < 21) return 1;
    
    const fingerTips = [8, 12, 16, 20];    // Index, Middle, Ring, Pinky tips
    const fingerMCPs = [5, 9, 13, 17];     // Index, Middle, Ring, Pinky MCPs
    const thumbTip = 4;
    const thumbIP = 3;
    
    let extendedCount = 0;
    
    // Check thumb (more sensitive threshold)
    const thumbDiff = keypoints[thumbTip].x - keypoints[thumbIP].x;
    if (Math.abs(thumbDiff) > 10) extendedCount++; // Reduced from 15 to 10
    
    // Check other fingers (more sensitive)
    for (let i = 0; i < 4; i++) {
      const tipY = keypoints[fingerTips[i]].y;
      const mcpY = keypoints[fingerMCPs[i]].y;
      if (mcpY - tipY > 20) extendedCount++; // Reduced from 25 to 20
    }
    
    // Add some hysteresis to prevent jitter
    const result = Math.max(1, Math.min(extendedCount, 5));
    debugLog(`üñêÔ∏è Finger count: ${result} (extended: ${extendedCount})`);
    return result;
  }

  // Simple hand depth calculation
  function calculateHandDepth(keypoints) {
    if (!keypoints || keypoints.length < 21) return 0.5;
    
    const wrist = keypoints[0];
    const middleTip = keypoints[12];
    
    if (!wrist || !middleTip) return 0.5;
    
    const distance = Math.sqrt(
      Math.pow(middleTip.x - wrist.x, 2) + 
      Math.pow(middleTip.y - wrist.y, 2)
    );
    
    // Map distance to volume (40-120 pixel range)
    const minDistance = 40;
    const maxDistance = 120;
    return Math.max(0, Math.min(1, (distance - minDistance) / (maxDistance - minDistance)));
  }
  
  function render() {
    frameCount++;
    
    // Draw video feed
    if (webcamRunning) {
      vctx.save(); 
      vctx.scale(-1, 1); 
      vctx.drawImage(video, -width, 0, width, height); 
      vctx.restore();
    }

    // Clear overlay canvas
    octx.clearRect(0, 0, width, height);
    
    // Process hand detection and update FM synthesis
    const hands = processHands();
    handleFMGestures(hands);
    
    // Simple hand visualization
    ['left', 'right'].forEach(handType => {
      const hand = hands[handType];
      if (!hand) return;
      
      // Draw hand position
      octx.fillStyle = handType === 'left' ? '#ff4444' : '#4444ff';
      octx.beginPath();
      octx.arc(hand.x, hand.y, 20, 0, 2 * Math.PI);
      octx.fill();
      
      // Show finger count
      octx.fillStyle = 'white';
      octx.font = 'bold 16px Arial';
      octx.fillText(hand.fingerCount.toString(), hand.x - 5, hand.y + 5);
    });
    
    requestAnimationFrame(render);
  }

  // Initialize main collapse functionality
  function initializeMainCollapse() {
    if (isMainCollapsed) {
      const controls = document.getElementById('controls');
      controls.classList.add('collapsed');
      mainCollapseBtn.textContent = '‚ñ∂';
      debugLog('üéõÔ∏è Controls panel initialized as collapsed (mobile detected)');
    }
  }

  // Main collapse button event listener
  mainCollapseBtn.onclick = toggleMainCollapse;

  // [FM-Synth-v3] Arpeggio control event listeners
  if (ctrl.chordType) {
    ctrl.chordType.onchange = updateArpeggioSettings;
  }
  if (ctrl.arpeggioPattern) {
    ctrl.arpeggioPattern.onchange = updateArpeggioSettings;
  }
  if (ctrl.arpeggioSpeed) {
    ctrl.arpeggioSpeed.oninput = updateArpeggioSettings;
  }
  if (ctrl.arpeggioEnabled) {
    ctrl.arpeggioEnabled.onchange = () => {
      if (!ctrl.arpeggioEnabled.checked && isArpeggioPlaying) {
        stopArpeggio();
      }
      updateArpeggioSettings();
      initializeGlassSystem(); // Initialize Philip Glass dual-layer system
    };
  }

  // Initialize system components
  initializePanels();
  initializeMainCollapse(); // Initialize main collapse for mobile
  initializeAudio(); // Auto-start FM audio system
  initializeCamera(); // Start camera and hand detection
  debugLog('üéπ Starting Philip Glass composition engine v3');
  render();



})().catch(error => {
  console.error('‚ùå Fatal initialization error:', error);
  alert('Failed to initialize application: ' + error.message);
});
</script>
</body>
</html>