<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Accelerometer Audio Speed Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        .container {
            text-align: center;
            padding: 20px;
            width: 100%;
            max-width: 400px;
            position: relative;
            z-index: 1;
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .speed-display {
            font-size: 3rem;
            font-weight: 100;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 20px;
            display: inline-block;
        }

        .speed-label {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .orientation-indicator {
            width: 150px;
            height: 150px;
            margin: 20px auto;
            position: relative;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .orientation-dot {
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 50%;
            position: absolute;
            transition: all 0.1s ease-out;
            box-shadow: 0 0 20px rgba(255,255,255,0.8);
        }

        .control-button {
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 20px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 20px 10px;
            display: inline-block;
            min-width: 150px;
        }

        .control-button:active {
            transform: scale(0.95);
        }

        .control-button.active {
            background: rgba(255,255,255,0.3);
            box-shadow: 0 0 30px rgba(255,255,255,0.5);
        }

        .info {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 20px;
            line-height: 1.5;
        }

        .permission-request {
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            max-width: 350px;
        }

        .permission-request h2 {
            margin-bottom: 15px;
        }

        .permission-request p {
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .error-message {
            background: rgba(255,0,0,0.2);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .axis-info {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 10px;
        }

        @media (max-height: 700px) {
            .orientation-indicator {
                width: 150px;
                height: 150px;
            }
            .speed-display {
                font-size: 3rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Speed Control</h1>
        
        <div id="permission-screen" class="permission-request">
            <h2>Motion & Audio Access</h2>
            <p>Tilt your phone to control audio playback speed!</p>
            <p style="font-size: 0.85rem;">Face down: 0.1x speed<br>Face up: 100x speed</p>
            <button class="control-button" onclick="requestPermissionsAndStart()">Start</button>
        </div>

        <div id="main-interface" style="display: none;">
            <div class="ui-controls" id="ui-controls">
                <div class="speed-label">Playback Speed</div>
                <div class="speed-display" id="speed-value">1.0x</div>
                
                <div class="orientation-indicator">
                    <div class="orientation-dot" id="orientation-dot"></div>
                </div>
                
                <div class="axis-info" id="axis-info">Ready</div>
                
                <button class="control-button" id="play-button" onclick="togglePlayback()">Play</button>
                
                <div class="info">
                    Tilt your phone to control speed<br>
                    Face down = slow | Face up = fast
                </div>
            </div>
            
            <div id="character-display" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; justify-content: center; align-items: center; font-size: 60vh; font-weight: bold; color: white; text-shadow: 0 0 80px rgba(0,0,0,0.8), 0 0 40px rgba(255,255,255,0.5); z-index: 10; opacity: 0; transition: opacity 0.5s;"></div>
        </div>

        <div id="error-message" class="error-message" style="display: none;"></div>
    </div>

    <script>
        let audioContext;
        let audioBuffer;
        let sourceNode;
        let isPlaying = false;
        let currentSpeed = 1.0;
        let accelerometerData = { x: 0, y: 0, z: 0 };
        let startOffset = 0;
        let startTime = 0;
        
        // Granular synthesis for pitch preservation
        let grainSize = 0.1; // 100ms grains
        let grainOverlap = 0.5; // 50% overlap
        let grainNodes = [];
        let nextGrainTime = 0;
        let playbackPosition = 0;
        let gainNode;
        
        // Hanya text characters - now loads from source/hanya.txt
        let hanyaText = '觀自在菩薩行深般若波羅密多時照見五蘊皆空度一切苦厄舍利子色不異空空不異色色即是空空即是色受想行識亦復如是舍利子是諸法空相不生不滅不垢不淨不增不減是故空中無色無受想行識無眼耳鼻舌身意無色聲香味觸法無眼界乃至無意識界無無明亦無無明盡乃至無老死亦無老死盡無苦集滅道無智亦無得以無所得故菩提薩埵依般若波羅密多故心無罣礙無罣礙故無有恐怖遠離顛倒夢想究竟涅槃三世諸佛依般若波羅密多故得阿耨多羅三藐三菩提故知般若波羅密多是大神咒是大明咒是無上咒是無等等咒能除一切苦真實不虛故說般若波羅密多咒即說咒曰揭諦揭諦波羅揭諦波羅僧揭諦菩提薩婆訶摩訶般若波羅密多';
        let currentCharIndex = 0;
        
        // Try to load from file
        fetch('source/hanya.txt')
            .then(response => response.text())
            .then(text => {
                if (text.trim()) {
                    hanyaText = text.trim();
                    console.log('Loaded hanya text from file:', hanyaText.length, 'characters');
                }
            })
            .catch(err => {
                console.log('Using built-in hanya text');
            });

        // Initialize Web Audio for full speed control
        async function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create main gain node for output
            gainNode = audioContext.createGain();
            gainNode.gain.value = 0.8;
            gainNode.connect(audioContext.destination);
            
            try {
                const response = await fetch('tools/vocal.mp3');
                const arrayBuffer = await response.arrayBuffer();
                audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                console.log('Audio loaded successfully, duration:', audioBuffer.duration, 'seconds');
            } catch (error) {
                console.log('Failed to load vocal.mp3, creating generated tone');
                createGeneratedAudio();
            }
        }

        // Fallback: Generate a simple tone if vocal.mp3 is not available
        function createGeneratedAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create a simple repeating pattern
            const sampleRate = audioContext.sampleRate;
            const duration = 2; // 2 second loop
            const frameCount = sampleRate * duration;
            
            audioBuffer = audioContext.createBuffer(1, frameCount, sampleRate);
            const channelData = audioBuffer.getChannelData(0);
            
            // Generate a simple melody pattern
            for (let i = 0; i < frameCount; i++) {
                const time = i / sampleRate;
                const frequency = 440 * (1 + 0.5 * Math.sin(time * Math.PI * 2));
                channelData[i] = Math.sin(2 * Math.PI * frequency * time) * 0.3;
                
                // Add some harmonics
                channelData[i] += Math.sin(4 * Math.PI * frequency * time) * 0.1;
                channelData[i] += Math.sin(6 * Math.PI * frequency * time) * 0.05;
                
                // Apply envelope
                const envelope = Math.sin(time * Math.PI / duration);
                channelData[i] *= envelope;
            }
        }

        async function requestPermissionsAndStart() {
            try {
                // Initialize audio
                initAudio();
                
                // Request accelerometer permission for iOS 13+
                if (typeof DeviceMotionEvent !== 'undefined' && 
                    typeof DeviceMotionEvent.requestPermission === 'function') {
                    const permission = await DeviceMotionEvent.requestPermission();
                    if (permission !== 'granted') {
                        throw new Error('Motion permission denied');
                    }
                }
                
                // Start accelerometer monitoring
                startAccelerometer();
                
                // Show main interface
                document.getElementById('permission-screen').style.display = 'none';
                document.getElementById('main-interface').style.display = 'block';
                
            } catch (error) {
                showError('Permission error: ' + error.message);
            }
        }

        function startAccelerometer() {
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleMotion);
            } else {
                showError('Device motion not supported on this device');
            }
        }

        function handleMotion(event) {
            const acc = event.accelerationIncludingGravity;
            
            if (acc) {
                accelerometerData.x = acc.x || 0;
                accelerometerData.y = acc.y || 0;
                accelerometerData.z = acc.z || 0;
                
                // Calculate speed based on Z axis (face up/down orientation)
                // Z is approximately -10 when face up, +10 when face down
                // Normalize to 0-1 range
                let normalizedZ = (accelerometerData.z + 10) / 20;
                normalizedZ = Math.max(0, Math.min(1, normalizedZ));
                
                // Map to speed range: 0.1x to 100x (logarithmic scale for better control)
                // Face down (z ≈ +10) = 0.1x, Face up (z ≈ -10) = 100x
                const minSpeed = 0.1;
                const maxSpeed = 100;
                
                // Invert the normalized value so face down is slow
                normalizedZ = 1 - normalizedZ;
                
                // Use exponential scaling for more intuitive control
                currentSpeed = minSpeed * Math.pow(maxSpeed / minSpeed, normalizedZ);
                
                // Update display
                updateDisplay();
                
                // Apply speed to audio
                applySpeedChange();
            }
        }

        function updateDisplay() {
            // Update speed display
            const speedDisplay = document.getElementById('speed-value');
            if (currentSpeed < 1) {
                speedDisplay.textContent = currentSpeed.toFixed(2) + 'x';
            } else if (currentSpeed < 10) {
                speedDisplay.textContent = currentSpeed.toFixed(1) + 'x';
            } else {
                speedDisplay.textContent = Math.round(currentSpeed) + 'x';
            }
            
            // Update orientation dot position
            const dot = document.getElementById('orientation-dot');
            const container = dot.parentElement;
            const maxOffset = 80;
            
            // Map accelerometer to dot position
            const xOffset = (accelerometerData.x / 10) * maxOffset;
            const yOffset = (accelerometerData.y / 10) * maxOffset;
            
            dot.style.transform = `translate(${xOffset}px, ${yOffset}px)`;
            
            // Update axis info
            const axisInfo = document.getElementById('axis-info');
            if (axisInfo) {
                axisInfo.textContent = `Z-axis: ${accelerometerData.z.toFixed(1)} | Speed: ${currentSpeed.toFixed(2)}x`;
            }
            
            // Don't change background - we're using hatsune_kannon image now
        }

        
        // Update the displayed character based on audio position
        function updateCharacterDisplay() {
            if (!audioBuffer || !isPlaying) return;
            
            // Calculate which character to show based on playback position
            const progressRatio = (playbackPosition % audioBuffer.duration) / audioBuffer.duration;
            const charIndex = Math.floor(progressRatio * hanyaText.length);
            
            // Update the character display
            const charDisplay = document.getElementById('character-display');
            if (charDisplay) {
                charDisplay.textContent = hanyaText[charIndex] || '';
            }
        }
        
        function applySpeedChange() {
            if (!isPlaying || !sourceNode) return;
            
            // Simply update the playback rate - no need to recreate the source
            // This provides smooth, real-time speed changes
            sourceNode.playbackRate.setValueAtTime(currentSpeed, audioContext.currentTime);
        }

        function togglePlayback() {
            const button = document.getElementById('play-button');
            
            if (!isPlaying) {
                startPlayback();
                button.textContent = 'Pause';
                button.classList.add('active');
            } else {
                stopPlayback();
                button.textContent = 'Play';
                button.classList.remove('active');
            }
        }

        function startPlayback() {
            if (!audioBuffer) {
                showError('Audio not loaded yet, please wait...');
                return;
            }
            
            isPlaying = true;
            startOffset = 0;
            
            // Create and start source node with current speed
            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.loop = true;
            sourceNode.playbackRate.value = currentSpeed * 0.8; // 20% lower pitch
            sourceNode.connect(gainNode);
            sourceNode.start(0);
            startTime = audioContext.currentTime;
            
            // Hide all UI controls and show character display
            const uiControls = document.getElementById('ui-controls');
            const charDisplay = document.getElementById('character-display');
            if (uiControls) {
                uiControls.style.display = 'none';
            }
            if (charDisplay) {
                charDisplay.style.opacity = '1';
            }
            
            // Start character update loop
            updateCharacterLoop();
        }
        
        function updateCharacterLoop() {
            if (!isPlaying) return;
            
            // Calculate current position based on playback speed
            const elapsed = (audioContext.currentTime - startTime) * currentSpeed;
            playbackPosition = elapsed % audioBuffer.duration;
            
            // Update character display
            updateCharacterDisplay();
            
            // Continue loop
            requestAnimationFrame(updateCharacterLoop);
        }

        function stopPlayback() {
            if (sourceNode) {
                try {
                    sourceNode.stop();
                    sourceNode.disconnect();
                } catch (e) {}
                sourceNode = null;
            }
            isPlaying = false;
            startOffset = 0;
            
            // Show UI controls again and hide character display
            const uiControls = document.getElementById('ui-controls');
            const charDisplay = document.getElementById('character-display');
            if (uiControls) {
                uiControls.style.display = 'block';
            }
            if (charDisplay) {
                charDisplay.textContent = '';
                charDisplay.style.opacity = '0';
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            stopPlayback();
            if (audioContext) {
                audioContext.close();
            }
        });
    </script>
</body>
</html>