<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Heart Rate & HRV Camera App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; margin: 0; padding: 1em; background: #f1f1f1; }
    #video { display: none; }
    #output { margin-top: 2em; }
    #start, #stop { padding: 1em 2em; font-size: 1.2em; margin-right: 1em; }
    #chart { width: 100%; height: 200px; }
    .reading { margin: 1em 0; font-size: 1.2em; }
  </style>
</head>
<body>
  <h1>Heart Rate & HRV Camera App</h1>
  <p>Place your fingertip gently over your phone's rear camera and flashlight.<br>
  Press <b>Start</b> and keep still. Your heart rate and HRV will be estimated in ~30 seconds.</p>
  
  <button id="start">Start</button>
  <button id="stop" disabled>Stop</button>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas" width="320" height="240" style="display:none;"></canvas>
  <div id="output">
    <div class="reading" id="bpm"></div>
    <div class="reading" id="hrv"></div>
    <canvas id="chart"></canvas>
    <div id="tips" style="color:#888; font-size:0.9em;"></div>
  </div>
  <script>
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let chart = document.getElementById('chart');
    let chartCtx = chart.getContext('2d');
    let startBtn = document.getElementById('start');
    let stopBtn = document.getElementById('stop');
    let bpmDiv = document.getElementById('bpm');
    let hrvDiv = document.getElementById('hrv');
    let tips = document.getElementById('tips');
    let stream = null;
    let capturing = false;
    let samples = [];
    let times = [];
    let lastPeakTime = null;
    let rrIntervals = [];
    let drawId = null;
    let torchTrack = null;

    // Start camera with torch (if supported)
    async function startCamera() {
      const constraints = {
        video: {
          facingMode: 'environment',
          width: { ideal: 320 },
          height: { ideal: 240 },
          frameRate: { ideal: 30 }
        }
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      // Try to enable torch
      const track = stream.getVideoTracks()[0];
      torchTrack = track;
      const capabilities = track.getCapabilities();
      if (capabilities.torch) {
        try {
          await track.applyConstraints({ advanced: [{ torch: true }] });
        } catch (e) {
          tips.textContent = "Torch not available or permission denied. Use a flashlight if needed.";
        }
      } else {
        tips.textContent = "Torch not supported. Use a flashlight if needed.";
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      if (torchTrack) {
        try { torchTrack.applyConstraints({ advanced: [{ torch: false }] }); } catch {}
        torchTrack = null;
      }
    }

    function resetData() {
      samples = [];
      times = [];
      lastPeakTime = null;
      rrIntervals = [];
      bpmDiv.textContent = '';
      hrvDiv.textContent = '';
      chartCtx.clearRect(0, 0, chart.width, chart.height);
    }

    // Extract average red pixel value from a frame
    function getRedValue() {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      let frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let sum = 0, count = 0;
      for (let i = 0; i < frame.data.length; i += 4) {
        sum += frame.data[i]; // R
        count++;
      }
      return sum / count;
    }

    // Simple peak detection for heartbeat (PPG)
    function detectPeak(window) {
      let max = Math.max(...window);
      let idx = window.lastIndexOf(max);
      // Only count as peak if it's the max in the 0.5s window and not at the edge
      return idx > 0 && idx < window.length - 1 && window[idx] > window[idx - 1] && window[idx] > window[idx + 1];
    }

    function drawChart(data) {
      chartCtx.clearRect(0, 0, chart.width, chart.height);
      if (data.length < 2) return;
      chartCtx.beginPath();
      chartCtx.moveTo(0, chart.height - (data[0] - Math.min(...
