<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Heart Rate & HRV Camera App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; margin: 0; padding: 1em; background: #f1f1f1; }
    #video { display: none; }
    #output { margin-top: 2em; }
    #start, #stop { padding: 1em 2em; font-size: 1.2em; margin-right: 1em; }
    #chart { width: 100%; height: 200px; }
    .reading { margin: 1em 0; font-size: 1.2em; }
  </style>
</head>
<body>
  <h1>Heart Rate & HRV Camera App</h1>
  <p>Place your fingertip gently over your phone's rear camera and flashlight.<br>
  Press <b>Start</b> and keep still. Your heart rate and HRV will be estimated in ~30 seconds.</p>
  
  <button id="start">Start</button>
  <button id="stop" disabled>Stop</button>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas" width="320" height="240" style="display:none;"></canvas>
  <div id="output">
    <div class="reading" id="bpm"></div>
    <div class="reading" id="hrv"></div>
    <canvas id="chart"></canvas>
    <div id="tips" style="color:#888; font-size:0.9em;"></div>
  </div>
  <script>
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let chart = document.getElementById('chart');
    let chartCtx = chart.getContext('2d');
    let startBtn = document.getElementById('start');
    let stopBtn = document.getElementById('stop');
    let bpmDiv = document.getElementById('bpm');
    let hrvDiv = document.getElementById('hrv');
    let tips = document.getElementById('tips');
    let stream = null;
    let capturing = false;
    let samples = [];
    let times = [];
    let lastPeakTime = null;
    let rrIntervals = [];
    let drawId = null;
    let torchTrack = null;

    // Start camera with torch (if supported)
    async function startCamera() {
      const constraints = {
        video: {
          facingMode: 'environment',
          width: { ideal: 320 },
          height: { ideal: 240 },
          frameRate: { ideal: 30 }
        }
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      // Try to enable torch
      const track = stream.getVideoTracks()[0];
      torchTrack = track;
      const capabilities = track.getCapabilities();
      if (capabilities.torch) {
        try {
          await track.applyConstraints({ advanced: [{ torch: true }] });
        } catch (e) {
          tips.textContent = "Torch not available or permission denied. Use a flashlight if needed.";
        }
      } else {
        tips.textContent = "Torch not supported. Use a flashlight if needed.";
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      if (torchTrack) {
        try { torchTrack.applyConstraints({ advanced: [{ torch: false }] }); } catch {}
        torchTrack = null;
      }
    }

    function resetData() {
      samples = [];
      times = [];
      lastPeakTime = null;
      rrIntervals = [];
      bpmDiv.textContent = '';
      hrvDiv.textContent = '';
      chartCtx.clearRect(0, 0, chart.width, chart.height);
    }

    // Extract average red pixel value from a frame
    function getRedValue() {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      let frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let sum = 0, count = 0;
      for (let i = 0; i < frame.data.length; i += 4) {
        sum += frame.data[i]; // R
        count++;
      }
      return sum / count;
    }

    // Simple peak detection for heartbeat (PPG)
    function detectPeak(window) {
      let max = Math.max(...window);
      let idx = window.lastIndexOf(max);
      // Only count as peak if it's the max in the 0.5s window and not at the edge
      return idx > 0 && idx < window.length - 1 && window[idx] > window[idx - 1] && window[idx] > window[idx + 1];
    }

    function drawChart(data) {
      chartCtx.clearRect(0, 0, chart.width, chart.height);
      if (data.length < 2) return;
      chartCtx.beginPath();
      chartCtx.moveTo(0, chart.height - (data[0] - Math.min(...data)) / (Math.max(...data) - Math.min(...data)) * chart.height);
      for (let i = 1; i < data.length; i++) {
        chartCtx.lineTo(i / (data.length - 1) * chart.width, chart.height - (data[i] - Math.min(...data)) / (Math.max(...data) - Math.min(...data)) * chart.height);
      }
      chartCtx.strokeStyle = 'red';
      chartCtx.stroke();
    }

    // --- Add event listeners and main logic ---

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      stopBtn.disabled = false;
      tips.textContent = 'Requesting camera permission...';
      try {
        await startCamera();
        tips.textContent = 'Camera started. Place your fingertip over the camera and flashlight.';
        capturing = true;
        resetData();
        video.style.display = 'block';
        sampleLoop();
      } catch (e) {
        tips.textContent = 'Camera permission denied or not available.';
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    });

    stopBtn.addEventListener('click', () => {
      capturing = false;
      stopCamera();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      video.style.display = 'none';
      tips.textContent = 'Measurement stopped.';
    });

    // Main sampling loop
    async function sampleLoop() {
      if (!capturing) return;
      const red = getRedValue();
      samples.push(red);
      times.push(Date.now());
      drawChart(samples);

      // Peak detection (simple, for demo)
      const windowSize = 15; // ~0.5s at 30fps
      if (samples.length > windowSize) {
        const window = samples.slice(-windowSize);
        if (detectPeak(window)) {
          const now = Date.now();
          if (lastPeakTime && now - lastPeakTime > 300) { // at least 0.3s between peaks
            const rr = now - lastPeakTime;
            rrIntervals.push(rr);
            // Calculate BPM
            const bpm = Math.round(60000 / rr);
            bpmDiv.textContent = `Heart Rate: ${bpm} BPM`;
            // Calculate HRV (SDNN)
            if (rrIntervals.length > 1) {
              const mean = rrIntervals.reduce((a, b) => a + b, 0) / rrIntervals.length;
              const sdnn = Math.sqrt(rrIntervals.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / (rrIntervals.length - 1));
              hrvDiv.textContent = `HRV (SDNN): ${Math.round(sdnn)} ms`;
            }
          }
          lastPeakTime = now;
        }
      }
      drawId = requestAnimationFrame(sampleLoop);
    }

    // --- UI improvements ---

    // Add some tips for the user
    tips.textContent = 'Press Start to measure your heart rate.';

    // Adjust canvas size on window resize
    window.addEventListener('resize', () => {
      canvas.width = video.clientWidth;
      canvas.height = video.clientHeight;
      drawChart(samples);
    });

    // Hide video element when not capturing
    video.addEventListener('playing', () => {
      setTimeout(() => {
        if (!capturing) video.style.display = 'none';
      }, 3000);
    });

  </script>
</body>
</html>
